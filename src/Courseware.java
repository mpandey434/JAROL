
import java.net.URISyntaxException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author MITESH PANDEY
 */
public class Courseware extends javax.swing.JFrame {

    /**
     * Creates new form Courseware
     */
    public Courseware() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jTabbedPane2 = new javax.swing.JTabbedPane();
        jPanel2 = new javax.swing.JPanel();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextArea3 = new javax.swing.JTextArea();
        jPanel3 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jPanel4 = new javax.swing.JPanel();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTextArea4 = new javax.swing.JTextArea();
        jPanel5 = new javax.swing.JPanel();
        jScrollPane5 = new javax.swing.JScrollPane();
        jTextArea5 = new javax.swing.JTextArea();
        jPanel6 = new javax.swing.JPanel();
        jScrollPane6 = new javax.swing.JScrollPane();
        jTextArea6 = new javax.swing.JTextArea();
        jPanel7 = new javax.swing.JPanel();
        jScrollPane7 = new javax.swing.JScrollPane();
        jTextArea7 = new javax.swing.JTextArea();
        jPanel9 = new javax.swing.JPanel();
        jScrollPane8 = new javax.swing.JScrollPane();
        jTextArea8 = new javax.swing.JTextArea();
        jPanel10 = new javax.swing.JPanel();
        jScrollPane9 = new javax.swing.JScrollPane();
        jTextArea9 = new javax.swing.JTextArea();
        jPanel11 = new javax.swing.JPanel();
        jScrollPane10 = new javax.swing.JScrollPane();
        jTextArea10 = new javax.swing.JTextArea();
        jPanel12 = new javax.swing.JPanel();
        jScrollPane11 = new javax.swing.JScrollPane();
        jTextArea11 = new javax.swing.JTextArea();
        jPanel8 = new javax.swing.JPanel();
        jScrollPane12 = new javax.swing.JScrollPane();
        jTextArea12 = new javax.swing.JTextArea();
        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setText("CourseWare ");

        jTextArea3.setColumns(20);
        jTextArea3.setRows(5);
        jTextArea3.setText("When we consider a Java program it can be defined as a collection of objects that communicate via invoking each other's methods. Let us now briefly look into what do class, object, methods and instance variables mean.\n\nObject - Objects have states and behaviours. Example: A dog has states - colour, name, breed as well as behaviours -wagging, barking, eating. An object is an instance of a class.\n\nClass - A class can be defined as a template/ blue print that describes the behaviours/states that object of its type support.\n\nMethods - A method is basically a behaviour. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.\n\nInstance Variables - Each object has its unique set of instance variables. An object's state is created by the values assigned to these instance variables.\n\nFirst Java Program:\nLet us look at a simple code that would print the words Hello World.\n\npublic class MyFirstJavaProgram {\n\n   /* This is my first java program.  \n    * This will print 'Hello World' as the output\n    */\n\t\n    public static void main(String []args) {\n       System.out.println(\"Hello World\"); // prints Hello World\n    }\n} \nLet's look at how to save the file, compile and run the program. Please follow the steps given below:\n\nOpen notepad and add the code as above.\n\nSave the file as: MyFirstJavaProgram.java.\n\nOpen a command prompt window and go to the directory where you saved the class. Assume it's C:\\.\n\nType ' javac MyFirstJavaProgram.java' and press enter to compile your code. If there are no errors in your code, the command prompt will take you to the next line (Assumption : The path variable is set).\n\nNow, type ' java MyFirstJavaProgram ' to run your program.\n\nYou will be able to see ' Hello World ' printed on the window.\n\nC:\\> javac MyFirstJavaProgram.java\nC:\\> java MyFirstJavaProgram \nHello World\nBasic Syntax:\nAbout Java programs, it is very important to keep in mind the following points.\n\nCase Sensitivity - Java is case sensitive, which means identifier Hello and hello would have different meaning in Java.\n\nClass Names - For all class names the first letter should be in Upper Case. \n\nIf several words are used to form a name of the class, each inner word's first letter should be in Upper Case.\n\nExample class MyFirstJavaClass\n\nMethod Names - All method names should start with a Lower Case letter. \n\nIf several words are used to form the name of the method, then each inner word's first letter should be in Upper Case.\n\nExample public void myMethodName()\n\nProgram File Name - Name of the program file should exactly match the class name. \n\nWhen saving the file, you should save it using the class name (Remember Java is case sensitive) and append '.java' to the end of the name (if the file name and the class name do not match your program will not compile).\n\nExample: Assume 'MyFirstJavaProgram' is the class name. Then the file should be saved as 'MyFirstJavaProgram.java'\n\npublic static void main(String args[]) - Java program processing starts from the main() method which is a mandatory part of every Java program.\n\nJava Identifiers:\nAll Java components require names. Names used for classes, variables and methods are called identifiers.\n\nIn Java, there are several points to remember about identifiers. They are as follows:\n\nAll identifiers should begin with a letter (A to Z or a to z), currency character ($) or an underscore (_).\n\nAfter the first character identifiers can have any combination of characters.\n\nA key word cannot be used as an identifier.\n\nMost importantly identifiers are case sensitive.\n\nExamples of legal identifiers: age, $salary, _value, __1_value\n\nExamples of illegal identifiers: 123abc, -salary\n\nJava Modifiers:\nLike other languages, it is possible to modify classes, methods, etc., by using modifiers. There are two categories of modifiers:\n\nAccess Modifiers: default, public , protected, private\n\nNon-access Modifiers: final, abstract, strictfp\n\nWe will be looking into more details about modifiers in the next section.\n\nJava Variables:\nWe would see following type of variables in Java:\n\nLocal Variables\nClass Variables (Static Variables)\nInstance Variables (Non-static variables)\nJava Arrays:\nArrays are objects that store multiple variables of the same type. However, an array itself is an object on the heap. We will look into how to declare, construct and initialize in the upcoming chapters.\n\nJava Enums:\nEnums were introduced in java 5.0. Enums restrict a variable to have one of only a few predefined values. The values in this enumerated list are called enums.\n\nWith the use of enums it is possible to reduce the number of bugs in your code.\n\nFor example, if we consider an application for a fresh juice shop, it would be possible to restrict the glass size to small, medium and large. This would make sure that it would not allow anyone to order any size other than the small, medium or large.\n\nExample:\nclass FreshJuice {\n\n   enum FreshJuiceSize{ SMALL, MEDIUM, LARGE }\n   FreshJuiceSize size;\n}\n\npublic class FreshJuiceTest {\n\n   public static void main(String args[]){\n      FreshJuice juice = new FreshJuice();\n      juice.size = FreshJuice.FreshJuiceSize.MEDIUM ;\n      System.out.println(\"Size: \" + juice.size);\n   }\n}\nAbove example will produce the following result:\n\nSize: MEDIUM\nNote: enums can be declared as their own or inside a class. Methods, variables, constructors can be defined inside enums as well.\n\nJava Keywords:\nThe following list shows the reserved words in Java. These reserved words may not be used as constant or variable or any other identifier names.\n\nabstract\tassert\tboolean\tbreak\nbyte\tcase\tcatch\tchar\nclass\tconst\tcontinue\tdefault\ndo\tdouble\telse\tenum\nextends\tfinal\tfinally\tfloat\nfor\tgoto\tif\timplements\nimport\tinstanceof\tint\tinterface\nlong\tnative\tnew\tpackage\nprivate\tprotected\tpublic\treturn\nshort\tstatic\tstrictfp\tsuper\nswitch\tsynchronized\tthis\tthrow\nthrows\ttransient\ttry\tvoid\nvolatile\twhile\t\t\nComments in Java\nJava supports single-line and multi-line comments very similar to c and c++. All characters available inside any comment are ignored by Java compiler.\n\npublic class MyFirstJavaProgram{\n\n   /* This is my first java program.\n    * This will print 'Hello World' as the output\n    * This is an example of multi-line comments.\n    */\n\n    public static void main(String []args){\n       // This is an example of single line comment\n       /* This is also an example of single line comment. */\n       System.out.println(\"Hello World\"); \n    }\n} \nUsing Blank Lines:\nA line containing only white space, possibly with a comment, is known as a blank line, and Java totally ignores it.\n\nInheritance:\nIn Java, classes can be derived from classes. Basically if you need to create a new class and here is already a class that has some of the code you require, then it is possible to derive your new class from the already existing code.\n\nThis concept allows you to reuse the fields and methods of the existing class without having to rewrite the code in a new class. In this scenario the existing class is called the superclass and the derived class is called the subclass.\n\nInterfaces:\nIn Java language, an interface can be defined as a contract between objects on how to communicate with each other. Interfaces play a vital role when it comes to the concept of inheritance.\n\nAn interface defines the methods, a deriving class(subclass) should use. But the implementation of the methods is totally up to the subclass.");
        jScrollPane3.setViewportView(jTextArea3);

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 1049, Short.MAX_VALUE)
                .addGap(39, 39, 39))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane3, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 456, Short.MAX_VALUE)
        );

        jTabbedPane2.addTab("Basic Syntax", jPanel2);

        jTextArea2.setColumns(20);
        jTextArea2.setRows(5);
        jTextArea2.setText("A variable provides us with named storage that our programs can manipulate. Each variable in Java has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.\n\nYou must declare all variables before they can be used. The basic form of a variable declaration is shown here:\n\ndata type variable [ = value][, variable [= value] ...] ;\nHere data type is one of Java's datatypes and variable is the name of the variable. To declare more than one variable of the specified type, you can use a comma-separated list.\n\nFollowing are valid examples of variable declaration and initialization in Java:\n\nint a, b, c;         // Declares three ints, a, b, and c.\nint a = 10, b = 10;  // Example of initialization\nbyte B = 22;         // initializes a byte type variable B.\ndouble pi = 3.14159; // declares and assigns a value of PI.\nchar a = 'a';        // the char variable a iis initialized with value 'a'\nThis chapter will explain various variable types available in Java Language. There are three kinds of variables in Java:\n\nLocal variables\n\nInstance variables\n\nClass/static variables\n\nLocal variables:\nLocal variables are declared in methods, constructors, or blocks.\n\nLocal variables are created when the method, constructor or block is entered and the variable will be destroyed once it exits the method, constructor or block.\n\nAccess modifiers cannot be used for local variables.\n\nLocal variables are visible only within the declared method, constructor or block.\n\nLocal variables are implemented at stack level internally.\n\nThere is no default value for local variables so local variables should be declared and an initial value should be assigned before the first use.\n\nExample:\nHere, age is a local variable. This is defined inside pupAge() method and its scope is limited to this method only.\n\npublic class Test{ \n   public void pupAge(){\n      int age = 0;\n      age = age + 7;\n      System.out.println(\"Puppy age is : \" + age);\n   }\n   \n   public static void main(String args[]){\n      Test test = new Test();\n      test.pupAge();\n   }\n}\nThis would produce the following result:\n\nPuppy age is: 7\nExample:\nFollowing example uses age without initializing it, so it would give an error at the time of compilation.\n\npublic class Test{ \n   public void pupAge(){\n      int age;\n      age = age + 7;\n      System.out.println(\"Puppy age is : \" + age);\n   }\n   \n   public static void main(String args[]){\n      Test test = new Test();\n      test.pupAge();\n   }\n}\nThis would produce the following error while compiling it:\n\nTest.java:4:variable number might not have been initialized\nage = age + 7;\n         ^\n1 error\nInstance variables:\nInstance variables are declared in a class, but outside a method, constructor or any block.\n\nWhen a space is allocated for an object in the heap, a slot for each instance variable value is created.\n\nInstance variables are created when an object is created with the use of the keyword 'new' and destroyed when the object is destroyed.\n\nInstance variables hold values that must be referenced by more than one method, constructor or block, or essential parts of an object's state that must be present throughout the class.\n\nInstance variables can be declared in class level before or after use.\n\nAccess modifiers can be given for instance variables.\n\nThe instance variables are visible for all methods, constructors and block in the class. Normally, it is recommended to make these variables private (access level). However visibility for subclasses can be given for these variables with the use of access modifiers.\n\nInstance variables have default values. For numbers the default value is 0, for Booleans it is false and for object references it is null. Values can be assigned during the declaration or within the constructor.\n\nInstance variables can be accessed directly by calling the variable name inside the class. However within static methods and different class ( when instance variables are given accessibility) should be called using the fully qualified name . ObjectReference.VariableName.\n\nExample:\nimport java.io.*;\n\npublic class Employee{\n   // this instance variable is visible for any child class.\n   public String name;\n   \n   // salary  variable is visible in Employee class only.\n   private double salary;\n   \n   // The name variable is assigned in the constructor. \n   public Employee (String empName){\n      name = empName;\n   }\n\n   // The salary variable is assigned a value.\n   public void setSalary(double empSal){\n      salary = empSal;\n   }\n   \n   // This method prints the employee details.\n   public void printEmp(){\n      System.out.println(\"name  : \" + name );\n      System.out.println(\"salary :\" + salary);\n   }\n\n   public static void main(String args[]){\n      Employee empOne = new Employee(\"Ransika\");\n      empOne.setSalary(1000);\n      empOne.printEmp();\n   }\n}\nThis would produce the following result:\n\nname  : Ransika\nsalary :1000.0\nClass/static variables:\nClass variables also known as static variables are declared with the static keyword in a class, but outside a method, constructor or a block.\n\nThere would only be one copy of each class variable per class, regardless of how many objects are created from it.\n\nStatic variables are rarely used other than being declared as constants. Constants are variables that are declared as public/private, final and static. Constant variables never change from their initial value.\n\nStatic variables are stored in static memory. It is rare to use static variables other than declared final and used as either public or private constants.\n\nStatic variables are created when the program starts and destroyed when the program stops.\n\nVisibility is similar to instance variables. However, most static variables are declared public since they must be available for users of the class.\n\nDefault values are same as instance variables. For numbers, the default value is 0; for Booleans, it is false; and for object references, it is null. Values can be assigned during the declaration or within the constructor. Additionally values can be assigned in special static initializer blocks.\n\nStatic variables can be accessed by calling with the class name ClassName.VariableName.\n\nWhen declaring class variables as public static final, then variables names (constants) are all in upper case. If the static variables are not public and final the naming syntax is the same as instance and local variables.\n\nExample:\nimport java.io.*;\n\npublic class Employee{\n   // salary  variable is a private static variable\n   private static double salary;\n\n   // DEPARTMENT is a constant\n   public static final String DEPARTMENT = \"Development \";\n\n   public static void main(String args[]){\n      salary = 1000;\n      System.out.println(DEPARTMENT + \"average salary:\" + salary);\n   }\n}\nThis would produce the following result:\n\nDevelopment average salary:1000\nNote: If the variables are access from an outside class the constant should be accessed as Employee.DEPARTMENT");
        jScrollPane2.setViewportView(jTextArea2);

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 1078, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 445, Short.MAX_VALUE)
                .addContainerGap())
        );

        jTabbedPane2.addTab("Datatypes & Variables", jPanel3);

        jTextArea4.setColumns(20);
        jTextArea4.setRows(5);
        jTextArea4.setText("There may be a situation when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.\n\nProgramming languages provide various control structures that allow for more complicated execution paths.\n\nA loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:\n\nJava Tutorial\nJava programming language provides the following types of loop to handle looping requirements. Click the following links to check their detail.\n\nLoop Type\tDescription\nwhile loop\n\nRepeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.\nfor loop\n\nExecute a sequence of statements multiple times and abbreviates the code that manages the loop variable.\ndo...while loop\n\nLike a while statement, except that it tests the condition at the end of the loop body\nLoop Control Statements:\nLoop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.\n\nJava supports the following control statements. Click the following links to check their detail.\n\nControl Statement\tDescription\nbreak statement\n\nTerminates the loop or switch statement and transfers execution to the statement immediately following the loop or switch.\ncontinue statement\n\nCauses the loop to skip the remainder of its body and immediately retest its condition prior to reiterating.\nEnhanced for loop in Java:\nAs of Java 5, the enhanced for loop was introduced. This is mainly used to traverse collection of elements including arrays.\n\nSyntax:\nThe syntax of enhanced for loop is:\n\nfor(declaration : expression)\n{\n   //Statements\n}\nDeclaration: The newly declared block variable, which is of a type compatible with the elements of the array you are accessing. The variable will be available within the for block and its value would be the same as the current array element.\n\nExpression: This evaluates to the array you need to loop through. The expression can be an array variable or method call that returns an array.\n\nExample:\npublic class Test {\n\n   public static void main(String args[]){\n      int [] numbers = {10, 20, 30, 40, 50};\n\n      for(int x : numbers ){\n         System.out.print( x );\n         System.out.print(\",\");\n      }\n      System.out.print(\"\\n\");\n      String [] names ={\"James\", \"Larry\", \"Tom\", \"Lacy\"};\n      for( String name : names ) {\n         System.out.print( name );\n         System.out.print(\",\");\n      }\n   }\n}\nThis would produce the following result:\n\n10,20,30,40,50,\nJames,Larry,Tom,Lacy,\nDecision making structures have one or more conditions to be evaluated or tested by the program, along with a statement or statements that are to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.\n\nFollowing is the general form of a typical decision making structure found in most of the programming languages:\n\nJava Tutorial\nJava programming language provides following types of decision making statements. Click the following links to check their detail.\n\nStatement\tDescription\nif statement\n\nAn if statement consists of a boolean expression followed by one or more statements.\nif...else statement\n\nAn if statement can be followed by an optional else statement, which executes when the boolean expression is false.\nnested if statements\n\nYou can use one if or else if statement inside another if or else if statement(s).\nswitch statement\n\nA switch statement allows a variable to be tested for equality against a list of values.\nThe ? : Operator:\nWe have covered conditional operator ? : in previous chapter which can be used to replace if...else statements. It has the following general form:\n\nExp1 ? Exp2 : Exp3;\nWhere Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.\n\nTo determine the value of whole expression, initially exp1 is evaluated\n\nIf the value of exp1 is true, then the value of Exp2 will be the value of the whole expression.\nIf the value of exp1 is false, then Exp3 is evaluated and its value becomes the value of the entire expression.");
        jScrollPane4.setViewportView(jTextArea4);

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 1078, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 434, Short.MAX_VALUE)
                .addContainerGap())
        );

        jTabbedPane2.addTab("Loops & Decision Making", jPanel4);

        jTextArea5.setColumns(20);
        jTextArea5.setRows(5);
        jTextArea5.setText("Java provides a data structure, the array, which stores a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.\n\nInstead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables.\n\nThis tutorial introduces how to declare array variables, create arrays, and process arrays using indexed variables.\n\nDeclaring Array Variables:\nTo use an array in a program, you must declare a variable to reference the array, and you must specify the type of array the variable can reference. Here is the syntax for declaring an array variable:\n\ndataType[] arrayRefVar;   // preferred way.\n\nor\n\ndataType arrayRefVar[];  //  works but not preferred way.\nNote: The style dataType[] arrayRefVar is preferred. The style dataType arrayRefVar[] comes from the C/C++ language and was adopted in Java to accommodate C/C++ programmers.\n\nExample:\nThe following code snippets are examples of this syntax:\n\ndouble[] myList;         // preferred way.\n\nor\n\ndouble myList[];         //  works but not preferred way.\nCreating Arrays:\nYou can create an array by using the new operator with the following syntax:\n\narrayRefVar = new dataType[arraySize];\nThe above statement does two things:\n\nIt creates an array using new dataType[arraySize];\n\nIt assigns the reference of the newly created array to the variable arrayRefVar.\n\nDeclaring an array variable, creating an array, and assigning the reference of the array to the variable can be combined in one statement, as shown below:\n\ndataType[] arrayRefVar = new dataType[arraySize];\nAlternatively you can create arrays as follows:\n\ndataType[] arrayRefVar = {value0, value1, ..., valuek};\nThe array elements are accessed through the index. Array indices are 0-based; that is, they start from 0 to arrayRefVar.length-1.\n\nExample:\nFollowing statement declares an array variable, myList, creates an array of 10 elements of double type and assigns its reference to myList:\n\ndouble[] myList = new double[10];\nFollowing picture represents array myList. Here, myList holds ten double values and the indices are from 0 to 9.\n\nJava Array\nProcessing Arrays:\nWhen processing array elements, we often use either for loop or foreach loop because all of the elements in an array are of the same type and the size of the array is known.\n\nExample:\nHere is a complete example of showing how to create, initialize and process arrays:\n\npublic class TestArray {\n\n   public static void main(String[] args) {\n      double[] myList = {1.9, 2.9, 3.4, 3.5};\n\n      // Print all the array elements\n      for (int i = 0; i < myList.length; i++) {\n         System.out.println(myList[i] + \" \");\n      }\n      // Summing all elements\n      double total = 0;\n      for (int i = 0; i < myList.length; i++) {\n         total += myList[i];\n      }\n      System.out.println(\"Total is \" + total);\n      // Finding the largest element\n      double max = myList[0];\n      for (int i = 1; i < myList.length; i++) {\n         if (myList[i] > max) max = myList[i];\n      }\n      System.out.println(\"Max is \" + max);\n   }\n}\nThis would produce the following result:\n\n1.9\n2.9\n3.4\n3.5\nTotal is 11.7\nax is 3.5\nThe foreach Loops:\nJDK 1.5 introduced a new for loop known as foreach loop or enhanced for loop, which enables you to traverse the complete array sequentially without using an index variable.\n\nExample:\nThe following code displays all the elements in the array myList:\n\npublic class TestArray {\n\n   public static void main(String[] args) {\n      double[] myList = {1.9, 2.9, 3.4, 3.5};\n\n      // Print all the array elements\n      for (double element: myList) {\n         System.out.println(element);\n      }\n   }\n}\nThis would produce the following result:\n\n1.9\n2.9\n3.4\n3.5\nPassing Arrays to Methods:\nJust as you can pass primitive type values to methods, you can also pass arrays to methods. For example, the following method displays the elements in an int array:\n\npublic static void printArray(int[] array) {\n  for (int i = 0; i < array.length; i++) {\n    System.out.print(array[i] + \" \");\n  }\n}\nYou can invoke it by passing an array. For example, the following statement invokes the printArray method to display 3, 1, 2, 6, 4, and 2:\n\nprintArray(new int[]{3, 1, 2, 6, 4, 2});\nReturning an Array from a Method:\nA method may also return an array. For example, the method shown below returns an array that is the reversal of another array:\n\npublic static int[] reverse(int[] list) {\n  int[] result = new int[list.length];\n\n  for (int i = 0, j = result.length - 1; i < list.length; i++, j--) {\n    result[j] = list[i];\n  }\n  return result;\n}\nThe Arrays Class:\nThe java.util.Arrays class contains various static methods for sorting and searching arrays, comparing arrays, and filling array elements. These methods are overloaded for all primitive types.\n\nSN\tMethods with Description\n1\tpublic static int binarySearch(Object[] a, Object key)\nSearches the specified array of Object ( Byte, Int , double, etc.) for the specified value using the binary search algorithm. The array must be sorted prior to making this call. This returns index of the search key, if it is contained in the list; otherwise, (-(insertion point + 1).\n\n2\tpublic static boolean equals(long[] a, long[] a2)\nReturns true if the two specified arrays of longs are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. This returns true if the two arrays are equal. Same method could be used by all other primitive data types (Byte, short, Int, etc.)\n\n3\tpublic static void fill(int[] a, int val)\nAssigns the specified int value to each element of the specified array of ints. Same method could be used by all other primitive data types (Byte, short, Int etc.)\n\n4\tpublic static void sort(Object[] a)\nSorts the specified array of objects into ascending order, according to the natural ordering of its elements. Same method could be used by all other primitive data types ( Byte, short, Int, etc.)");
        jScrollPane5.setViewportView(jTextArea5);

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane5, javax.swing.GroupLayout.DEFAULT_SIZE, 1078, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane5, javax.swing.GroupLayout.DEFAULT_SIZE, 445, Short.MAX_VALUE))
        );

        jTabbedPane2.addTab("Arrays and Strings", jPanel5);

        jTextArea6.setColumns(20);
        jTextArea6.setRows(5);
        jTextArea6.setText("A Java method is a collection of statements that are grouped together to perform an operation. When you call the System.out.println() method, for example, the system actually executes several statements in order to display a message on the console.\n\nNow you will learn how to create your own methods with or without return values, invoke a method with or without parameters, and apply method abstraction in the program design.\n\nCreating Method:\nConsidering the following example to explain the syntax of a method:\n\npublic static int methodName(int a, int b) {\n  // body\n}\nHere,\n\npublic static : modifier.\n\nint: return type\n\nmethodName: name of the method\n\na, b: formal parameters\n\nint a, int b: list of parameters\n\nMethod definition consists of a method header and a method body. The same is shown below:\n\nmodifier returnType nameOfMethod (Parameter List) {\n // method body\n}\nThe syntax shown above includes:\n\nmodifier: It defines the access type of the method and it is optional to use.\n\nreturnType: Method may return a value.\n\nnameOfMethod: This is the method name. The method signature consists of the method name and the parameter list.\n\nParameter List: The list of parameters, it is the type, order, and number of parameters of a method. These are optional, method may contain zero parameters.\n\nmethod body: The method body defines what the method does with statements.\n\nExample:\nHere is the source code of the above defined method called max(). This method takes two parameters num1 and num2 and returns the maximum between the two:\n\n/** the snippet returns the minimum between two numbers */\npublic static int minFunction(int n1, int n2) {\n   int min;\n   if (n1 > n2)\n      min = n2;\n   else\n      min = n1;\n\n   return min; \n}\nMethod Calling:\nFor using a method, it should be called. There are two ways in which a method is called i.e. method returns a value or returning nothing (no return value).\n\nThe process of method calling is simple. When a program invokes a method, the program control gets transferred to the called method. This called method then returns control to the caller in two conditions, when:\n\nreturn statement is executed.\n\nreaches the method ending closing brace.\n\nThe methods returning void is considered as call to a statement. Lets consider an example:\n\nSystem.out.println(\"This is tutorialspoint.com!\");\nThe method returning value can be understood by the following example:\n\nint result = sum(6, 9);\nExample:\nFollowing is the example to demonstrate how to define a method and how to call it:\n\npublic class ExampleMinNumber{\n   \n   public static void main(String[] args) {\n      int a = 11;\n      int b = 6;\n      int c = minFunction(a, b);\n      System.out.println(\"Minimum Value = \" + c);\n   }\n\n   /** returns the minimum of two numbers */\n   public static int minFunction(int n1, int n2) {\n      int min;\n      if (n1 > n2)\n         min = n2;\n      else\n         min = n1;\n\n      return min; \n   }\n}\nThis would produce the following result:\n\ninimum value = 6\nThe void Keyword:\nThe void keyword allows us to create methods which do not return a value. Here, in the following example we're considering a void method methodRankPoints. This method is a void method which does not return any value. Call to a void method must be a statement i.e. methodRankPoints(255.7);. It is a Java statement which ends with a semicolon as shown below.\n\nExample:\npublic class ExampleVoid {\n\n   public static void main(String[] args) {\n      methodRankPoints(255.7);\n   }\n\n   public static void methodRankPoints(double points) {\n      if (points >= 202.5) {\n         System.out.println(\"Rank:A1\");\n      }\n      else if (points >= 122.4) {\n         System.out.println(\"Rank:A2\");\n      }\n      else {\n         System.out.println(\"Rank:A3\");\n      }\n   }\n}\nThis would produce the following result:\n\nRank:A1\nPassing Parameters by Value:\nWhile working under calling process, arguments is to be passed. These should be in the same order as their respective parameters in the method specification. Parameters can be passed by value or by reference.\n\nPassing Parameters by Value means calling a method with a parameter. Through this the argument value is passed to the parameter.\n\nExample:\nThe following program shows an example of passing parameter by value. The values of the arguments remains the same even after the method invocation.\n\npublic class swappingExample {\n\n   public static void main(String[] args) {\n      int a = 30;\n      int b = 45;\n\n      System.out.println(\"Before swapping, a = \" +\n                          a + \" and b = \" + b);\n\n      // Invoke the swap method\n      swapFunction(a, b);\n      System.out.println(\"\\n**Now, Before and After swapping values will be same here**:\");\n      System.out.println(\"After swapping, a = \" +\n                         a + \" and b is \" + b);\n   }\n\n   public static void swapFunction(int a, int b) {\n   \n      System.out.println(\"Before swapping(Inside), a = \" + a\n                           + \" b = \" + b);\n      // Swap n1 with n2\n      int c = a;\n      a = b;\n      b = c;\n\n      System.out.println(\"After swapping(Inside), a = \" + a\n                           + \" b = \" + b);\n   }\n}\nThis would produce the following result:\n\nBefore swapping, a = 30 and b = 45\nBefore swapping(Inside), a = 30 b = 45\nAfter swapping(Inside), a = 45 b = 30\n\n**Now, Before and After swapping values will be same here**:\nAfter swapping, a = 30 and b is 45\nMethod Overloading:\nWhen a class has two or more methods by same name but different parameters, it is known as method overloading. It is different from overriding. In overriding a method has same method name, type, number of parameters etc.\n\nLets consider the example shown before for finding minimum numbers of integer type. If, lets say we want to find minimum number of double type. Then the concept of Overloading will be introduced to create two or more methods with the same name but different parameters.\n\nThe below example explains the same:\n\npublic class ExampleOverloading{\n\n   public static void main(String[] args) {\n      int a = 11;\n      int b = 6;\n      double c = 7.3;\n      double d = 9.4;\n      int result1 = minFunction(a, b);\n      // same function name with different parameters\n      double result2 = minFunction(c, d);\n      System.out.println(\"Minimum Value = \" + result1);\n      System.out.println(\"Minimum Value = \" + result2);\n   }\n\n  // for integer\n   public static int minFunction(int n1, int n2) {\n      int min;\n      if (n1 > n2)\n         min = n2;\n      else\n         min = n1;\n\n      return min; \n   }\n   // for double\n   public static double minFunction(double n1, double n2) {\n     double min;\n      if (n1 > n2)\n         min = n2;\n      else\n         min = n1;\n\n      return min; \n   }\n}\nThis would produce the following result:\n\ninimum Value = 6\ninimum Value = 7.3\nOverloading methods makes program readable. Here, two methods are given same name but with different parameters. The minimum number from integer and double types is the result.\n\nUsing Command-Line Arguments:\nSometimes you will want to pass information into a program when you run it. This is accomplished by passing command-line arguments to main( ).\n\nA command-line argument is the information that directly follows the program's name on the command line when it is executed. To access the command-line arguments inside a Java program is quite easy.they are stored as strings in the String array passed to main( ).\n\nExample:\nThe following program displays all of the command-line arguments that it is called with:\n\npublic class CommandLine {\n\n   public static void main(String args[]){ \n      for(int i=0; i<args.length; i++){\n         System.out.println(\"args[\" + i + \"]: \" +\n                                           args[i]);\n      }\n   }\n}\nTry executing this program as shown here:\n\n$java CommandLine this is a command line 200 -100\nThis would produce the following result:\n\nargs[0]: this\nargs[1]: is\nargs[2]: a\nargs[3]: command\nargs[4]: line\nargs[5]: 200\nargs[6]: -100\nThe Constructors:\nA constructor initializes an object when it is created. It has the same name as its class and is syntactically similar to a method. However, constructors have no explicit return type.\n\nTypically, you will use a constructor to give initial values to the instance variables defined by the class, or to perform any other startup procedures required to create a fully formed object.\n\nAll classes have constructors, whether you define one or not, because Java automatically provides a default constructor that initializes all member variables to zero. However, once you define your own constructor, the default constructor is no longer used.\n\nExample:\nHere is a simple example that uses a constructor without parameters:\n\n// A simple constructor.\nclass MyClass {\n   int x;\n   \n   // Following is the constructor\n   MyClass() {\n      x = 10;\n   }\n}\nYou would call constructor to initialize objects as follows:\n\npublic class ConsDemo {\n\n   public static void main(String args[]) {\n      MyClass t1 = new MyClass();\n      MyClass t2 = new MyClass();\n      System.out.println(t1.x + \" \" + t2.x);\n   }\n}\nparametarized constructor\nMost often, you will need a constructor that accepts one or more parameters. Parameters are added to a constructor in the same way that they are added to a method, just declare them inside the parentheses after the constructor's name.\n\nExample:\nHere is a simple example that uses a constructor with parameter:\n\n// A simple constructor.\nclass MyClass {\n   int x;\n   \n   // Following is the constructor\n   MyClass(int i ) {\n      x = i;\n   }\n}\nYou would call constructor to initialize objects as follows:\n\npublic class ConsDemo {\n\n   public static void main(String args[]) {\n      MyClass t1 = new MyClass( 10 );\n      MyClass t2 = new MyClass( 20 );\n      System.out.println(t1.x + \" \" + t2.x);\n   }\n}\nThis would produce the following result:\n\n10 20\nThe this keyword\nthis is a keyword in Java which is used as a reference to the object of the current class, with in an instance method or a constructor. Using this you can refer the members of a class such as constructors, variables and methods.\n\nNoteThe keyword this is used only within instance methods or constructors\n\nJava Tutorial\n \n\nIn general the keyword this is used to :\nDifferentiate the instance variables from local variables if they have same names, within a constructor or a method.\n\nclass Student{\n\n   int age;   \n   Student(int age){\n   this.age=age;\t\n   }\n\n}\nCall one type of constructor( parametrized constructor or default ) from other in a class. It is known as explicit constructor invocation .\n\nclass Student{\n\n   int age\n   Student(){\n   this(20);\n   }\n   \n   Student(int age){\n   this.age=age;\t\n   }\n\n}\nExample\nHere is an example that uses this keyword to access the members of a class. Copy and paste the below given program in a file with name This_Example.java\n\npublic class This_Example {\n\t\n   //Instance variable num\n   int num=10;\n\t\n   This_Example(){\n      System.out.println(\"This is an example program on keyword this \");\t\n   }\n\n   This_Example(int num){\n      //Invoking the default constructor\n      this();\n      \n      //Assigning the local variable num to the instance variable num\n      this.num=num;\t   \n   }\n   \n   public void greet(){\n      System.out.println(\"Hi Welcome to Tutorialspoint\");\n   }\n      \n   public void print(){\n      //Local variable num\n      int num=20;\n      \n      //Printing the instance variable\n      System.out.println(\"value of local variable num is : \"+num);\n      \n      //Printing the local variable\n      System.out.println(\"value of instance variable num is : \"+this.num);\n      \n      //Invoking the greet method of a class\n      this.greet();     \n   }\n   \n   public static void main(String[] args){\n      //Instantiating the class\n      This_Example obj1=new This_Example();\n      \n      //Invoking the print method\n      obj1.print();\n\t  \n      //Passing a new value to the num variable through parametrized constructor\n      This_Example obj2=new This_Example(30);\n      \n      //Invoking the print method again\n      obj2.print(); \n   }\n\n}\nThis would produce the following result:\nThis is an example program on keyword this \nvalue of local variable num is : 20\nvalue of instance variable num is : 10\nHi Welcome to Tutorialspoint\nThis is an example program on keyword this \nvalue of local variable num is : 20\nvalue of instance variable num is : 30\nHi Welcome to Tutorialspoint\nVariable Arguments(var-args):\nJDK 1.5 enables you to pass a variable number of arguments of the same type to a method. The parameter in the method is declared as follows:\n\ntypeName... parameterName\nIn the method declaration, you specify the type followed by an ellipsis (...) Only one variable-length parameter may be specified in a method, and this parameter must be the last parameter. Any regular parameters must precede it.\n\nExample:\npublic class VarargsDemo {\n\n   public static void main(String args[]) {\n      // Call method with variable args  \n\t  printMax(34, 3, 3, 2, 56.5);\n      printMax(new double[]{1, 2, 3});\n   }\n\n   public static void printMax( double... numbers) {\n   if (numbers.length == 0) {\n      System.out.println(\"No argument passed\");\n      return;\n   }\n\n   double result = numbers[0];\n\n   for (int i = 1; i <  numbers.length; i++)\n      if (numbers[i] >  result)\n      result = numbers[i];\n      System.out.println(\"The max value is \" + result);\n   }\n}\nThis would produce the following result:\n\nThe max value is 56.5\nThe max value is 3.0\nThe finalize( ) Method:\nIt is possible to define a method that will be called just before an object's final destruction by the garbage collector. This method is called finalize( ), and it can be used to ensure that an object terminates cleanly.\n\nFor example, you might use finalize( ) to make sure that an open file owned by that object is closed.\n\nTo add a finalizer to a class, you simply define the finalize( ) method. The Java runtime calls that method whenever it is about to recycle an object of that class.\n\nInside the finalize( ) method, you will specify those actions that must be performed before an object is destroyed.\n\nThe finalize( ) method has this general form:\n\nprotected void finalize( )\n{\n   // finalization code here\n}\nHere, the keyword protected is a specifier that prevents access to finalize( ) by code defined outside its class.\n\nThis means that you cannot know when or even if finalize( ) will be executed. For example, if your program ends before garbage collection occurs, finalize( ) will not execute.");
        jScrollPane6.setViewportView(jTextArea6);

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane6, javax.swing.GroupLayout.DEFAULT_SIZE, 1088, Short.MAX_VALUE))
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane6, javax.swing.GroupLayout.DEFAULT_SIZE, 445, Short.MAX_VALUE))
        );

        jTabbedPane2.addTab("Methods", jPanel6);

        jTextArea7.setColumns(20);
        jTextArea7.setRows(5);
        jTextArea7.setText("An exception (or exceptional event) is a problem that arises during the execution of a program. When an Exception occurs the normal flow of the program is disrupted and the program/Application terminates abnormally, which is not recommended, therefore these exceptions are to be handled.\n\nAn exception can occur for many different reasons, below given are some scenarios where exception occurs.\n\nA user has entered invalid data.\n\nA file that needs to be opened cannot be found.\n\nA network connection has been lost in the middle of communications or the JVM has run out of memory.\n\nSome of these exceptions are caused by user error, others by programmer error, and others by physical resources that have failed in some manner.\n\nBased on these we have three categories of Exceptions you need to understand them to know how exception handling works in Java,\n\nChecked exceptions: A checked exception is an exception that occurs at the compile time, these are also called as compile time exceptions. These exceptions cannot simply be ignored at the time of compilation, the Programmer should take care of (handle) these exceptions.\n\nFor example, if you use FileReader class in your program to read data from a file, if the file specified in its constructor doesn't exist, then an FileNotFoundException occurs, and compiler prompts the programmer to handle the exception.\nimport java.io.File;\nimport java.io.FileReader;\n\npublic class FilenotFound_Demo {\n\n   public static void main(String args[]){\t\t\n      File file=new File(\"E://file.txt\");\n      FileReader fr = new FileReader(file); \n   }\n   \n} If you try to compile the above program you will get exceptions as shown below.\n \n\nC:\\>javac FilenotFound_Demo.java\nFilenotFound_Demo.java:8: error: unreported exception FileNotFoundException; must be caught or declared to be thrown\n      FileReader fr = new FileReader(file);\n                      ^\n1 error\nNote: Since the methods read() and close() of FileReader class throws IOException, you can observe that compiler notifies to handle IOException, along with FileNotFoundException.\n\nUnchecked exceptions: An Unchecked exception is an exception that occurs at the time of execution, these are also called as Runtime Exceptions, these include programming bugs, such as logic errors or improper use of an API. runtime exceptions are ignored at the time of compilation.\n\nFor example, if you have declared an array of size 5 in your program, and trying to call the 6th element of the array then an ArrayIndexOutOfBoundsExceptionexception occurs.\n\npublic class Unchecked_Demo {\n   \n   public static void main(String args[]){\n      int num[]={1,2,3,4};\n      System.out.println(num[5]);\n   }\n\n}\nIf you compile and execute the above program you will get exception as shown below.\n\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 5\n\tat Exceptions.Unchecked_Demo.main(Unchecked_Demo.java:8)\nErrors: These are not exceptions at all, but problems that arise beyond the control of the user or the programmer. Errors are typically ignored in your code because you can rarely do anything about an error. For example, if a stack overflow occurs, an error will arise. They are also ignored at the time of compilation.\n\nException Hierarchy:\nAll exception classes are subtypes of the java.lang.Exception class. The exception class is a subclass of the Throwable class. Other than the exception class there is another subclass called Error which is derived from the Throwable class.\n\nErrors are not normally trapped form the Java programs. These conditions normally happen in case of severe failures, which are not handled by the java programs. Errors are generated to indicate errors generated by the runtime environment. Example : JVM is out of Memory. Normally programs cannot recover from errors.\n\nThe Exception class has two main subclasses: IOException class and RuntimeException Class.\n\nJava Exceptions\nHere is a list of most common checked and unchecked Java's Built-in Exceptions.\n\nExceptions Methods:\nFollowing is the list of important medthods available in the Throwable class.\n\nSN\tMethods with Description\n1\tpublic String getMessage()\nReturns a detailed message about the exception that has occurred. This message is initialized in the Throwable constructor.\n\n2\tpublic Throwable getCause()\nReturns the cause of the exception as represented by a Throwable object.\n\n3\tpublic String toString()\nReturns the name of the class concatenated with the result of getMessage()\n\n4\tpublic void printStackTrace()\nPrints the result of toString() along with the stack trace to System.err, the error output stream.\n\n5\tpublic StackTraceElement [] getStackTrace()\nReturns an array containing each element on the stack trace. The element at index 0 represents the top of the call stack, and the last element in the array represents the method at the bottom of the call stack.\n\n6\tpublic Throwable fillInStackTrace()\nFills the stack trace of this Throwable object with the current stack trace, adding to any previous information in the stack trace.\n\nCatching Exceptions:\nA method catches an exception using a combination of the try and catch keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following:\n\ntry\n{\n   //Protected code\n}catch(ExceptionName e1)\n{\n   //Catch block\n}\nThe code which is prone to exceptions is placed in the try block, when an exception occurs, that exception occurred is handled by catch block associated with it. Every try block should be immediately followed either by a class block or finally block.\n\nA catch statement involves declaring the type of exception you are trying to catch. If an exception occurs in protected code, the catch block (or blocks) that follows the try is checked. If the type of exception that occurred is listed in a catch block, the exception is passed to the catch block much as an argument is passed into a method parameter.\n\nExample:\nThe following is an array is declared with 2 elements. Then the code tries to access the 3rd element of the array which throws an exception.\n\n// File Name : ExcepTest.java\nimport java.io.*;\npublic class ExcepTest{\n\n   public static void main(String args[]){\n      try{\n         int a[] = new int[2];\n         System.out.println(\"Access element three :\" + a[3]);\n      }catch(ArrayIndexOutOfBoundsException e){\n         System.out.println(\"Exception thrown  :\" + e);\n      }\n      System.out.println(\"Out of the block\");\n   }\n}\nThis would produce the following result:\n\nException thrown  :java.lang.ArrayIndexOutOfBoundsException: 3\nOut of the block\nMultiple catch Blocks:\nA try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following:\n\ntry\n{\n   //Protected code\n}catch(ExceptionType1 e1)\n{\n   //Catch block\n}catch(ExceptionType2 e2)\n{\n   //Catch block\n}catch(ExceptionType3 e3)\n{\n   //Catch block\n}\nThe previous statements demonstrate three catch blocks, but you can have any number of them after a single try. If an exception occurs in the protected code, the exception is thrown to the first catch block in the list. If the data type of the exception thrown matches ExceptionType1, it gets caught there. If not, the exception passes down to the second catch statement. This continues until the exception either is caught or falls through all catches, in which case the current method stops execution and the exception is thrown down to the previous method on the call stack.\n\nExample:\nHere is code segment showing how to use multiple try/catch statements.\n\ntry\n{\n   file = new FileInputStream(fileName);\n   x = (byte) file.read();\n}catch(IOException i)\n{\n   i.printStackTrace();\n   return -1;\n}catch(FileNotFoundException f) //Not valid!\n{\n   f.printStackTrace();\n   return -1;\n}\nCatching multiple type of exceptions\nSince Java 7 you can handle more than one exceptions using a single catch block, this feature simplifies the code. Below given is the syntax of writing\n\ncatch (IOException|FileNotFoundException ex) {\n   logger.log(ex);\n   throw ex;\nThe throws/throw Keywords:\nIf a method does not handle a checked exception, the method must declare it using the throws keyword. The throws keyword appears at the end of a method's signature.\n\nYou can throw an exception, either a newly instantiated one or an exception that you just caught, by using the throw keyword.\n\nTry to understand the difference between throws and throw keywords, throws is used to postpone the handling of a checked exception and throw is used to invoke an exception explicitly.\nThe following method declares that it throws a RemoteException:\n\nimport java.io.*;\npublic class className\n{\n   public void deposit(double amount) throws RemoteException\n   {\n      // Method implementation\n      throw new RemoteException();\n   }\n   //Remainder of class definition\n}\nA method can declare that it throws more than one exception, in which case the exceptions are declared in a list separated by commas. For example, the following method declares that it throws a RemoteException and an InsufficientFundsException:\n\nimport java.io.*;\npublic class className\n{\n   public void withdraw(double amount) throws RemoteException,\n                              InsufficientFundsException\n   {\n       // Method implementation\n   }\n   //Remainder of class definition\n}\nThe finally block\nThe finally block follows a try block or a catch block. A finally block of code always executes, irrespective of occurrence of an Exception.\n\nUsing a finally block allows you to run any cleanup-type statements that you want to execute, no matter what happens in the protected code.\n\nA finally block appears at the end of the catch blocks and has the following syntax:\n\ntry\n{\n   //Protected code\n}catch(ExceptionType1 e1)\n{\n   //Catch block\n}catch(ExceptionType2 e2)\n{\n   //Catch block\n}catch(ExceptionType3 e3)\n{\n   //Catch block\n}finally\n{\n   //The finally block always executes.\n}\nExample:\npublic class ExcepTest{\n\n   public static void main(String args[]){\n      int a[] = new int[2];\n      try{\n         System.out.println(\"Access element three :\" + a[3]);\n      }catch(ArrayIndexOutOfBoundsException e){\n         System.out.println(\"Exception thrown  :\" + e);\n      }\n      finally{\n         a[0] = 6;\n         System.out.println(\"First element value: \" +a[0]);\n         System.out.println(\"The finally statement is executed\");\n      }\n   }\n}\nThis would produce the following result:\n\nException thrown  :java.lang.ArrayIndexOutOfBoundsException: 3\nFirst element value: 6\nThe finally statement is executed\nNote the following:\n\nA catch clause cannot exist without a try statement.\n\nIt is not compulsory to have finally clauses when ever a try/catch block is present.\n\nThe try block cannot be present without either catch clause or finally clause.\n\nAny code cannot be present in between the try, catch, finally blocks.\n\nThe try-with-resources\nGenerally when we use any resources like streams, connections etc.. we have to close them explicitly using finally block. In the program given below we are reading data from a file using FileReader and we are closing it using finally block.\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class ReadData_Demo {\n\n   public static void main(String args[]){\n      FileReader fr=null;\t\t\n      try{\n         File file=new File(\"file.txt\");\n         fr = new FileReader(file);  char [] a = new char[50];\n         fr.read(a); // reads the content to the array\n         for(char c : a)\n         System.out.print(c); //prints the characters one by one\n      }catch(IOException e){\n          e.printStackTrace();\n       }\n       finally{\t\n          try{\n              fr.close();\n          }catch(IOException ex){\t\t\n               ex.printStackTrace();\n           }\n       }\n    }\n\n}\ntry-with-resources, also referred as automatic resource management. is a new exception handling mechanism that was introduced in Java7, which automatically closes the resources used within the try catch block.\n\nTo use this statement you simply need to declare the required resources within the parenthesis, the created resource will be closed automatically at the end of the block, below given is the syntax of try-with-resources statement.\n\ntry(FileReader fr=new FileReader(\"file path\"))\n   {\n   //use the resource\n   }catch(){\n      //body of catch \n    }\n   }\nBelow given is the program that reads the data in a file using try-with-resources statement.\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Try_withDemo {\n\n   public static void main(String args[]){\n      \t\t\n      try(FileReader fr=new FileReader(\"E://file.txt\")){\n         char [] a = new char[50];\n         fr.read(a); // reads the contentto the array\n         for(char c : a)\n         System.out.print(c); //prints the characters one by one\n      }catch(IOException e){\n          e.printStackTrace();\n       }   \n   }\n}\nFollowing points are to be kept in mind while working with try-with resources statement.\n\nTo use a class with try-with-resources statement it should implement AutoCloseable interface and the close() method of it gets invoked automatically at runtime.\n\nYou can declare more than one class in try-with-resources statement.\n\nwhile you declare multiple classes in the try block of try-with-resources statement these classes are closed in reverse order.\n\nExcept the deceleration of resources within the parenthesis every thing is same as normal try/catch block of a try block.\n\nThe resource declared in try gets instantiated just before the start of the try-block.\n\nThe resource declared at the try block is implicitly declared as final.\n\nUser-defined Exceptions:\nYou can create your own exceptions in Java. Keep the following points in mind when writing your own exception classes:\n\nAll exceptions must be a child of Throwable.\n\nIf you want to write a checked exception that is automatically enforced by the Handle or Declare Rule, you need to extend the Exception class.\n\nIf you want to write a runtime exception, you need to extend the RuntimeException class.\n\nWe can define our own Exception class as below:\n\nclass MyException extends Exception{\n}\nYou just need to extend the predefined Exception class to create your own Exception. These are considered to be checked exceptions. The following InsufficientFundsException class is a user-defined exception that extends the Exception class, making it a checked exception. An exception class is like any other class, containing useful fields and methods.\n\nExample:\n// File Name InsufficientFundsException.java\nimport java.io.*;\n\npublic class InsufficientFundsException extends Exception\n{\n   private double amount;\n   public InsufficientFundsException(double amount)\n   {\n      this.amount = amount;\n   } \n   public double getAmount()\n   {\n      return amount;\n   }\n}\nTo demonstrate using our user-defined exception, the following CheckingAccount class contains a withdraw() method that throws an InsufficientFundsException.\n\n// File Name CheckingAccount.java\nimport java.io.*;\n\npublic class CheckingAccount\n{\n   private double balance;\n   private int number;\n   \n   public CheckingAccount(int number)\n   {\n      this.number = number;\n   }\n   \n   public void deposit(double amount)\n   {\n      balance += amount;\n   }\n   \n   public void withdraw(double amount) throws InsufficientFundsException\n   {\n      if(amount <= balance)\n      {\n         balance -= amount;\n      }\n      else\n      {\n         double needs = amount - balance;\n         throw new InsufficientFundsException(needs);\n      }\n   }\n   \n   public double getBalance()\n   {\n      return balance;\n   }\n   \n   public int getNumber()\n   {\n      return number;\n   }\n}\nThe following BankDemo program demonstrates invoking the deposit() and withdraw() methods of CheckingAccount.\n\n// File Name BankDemo.java\npublic class BankDemo\n{\n   public static void main(String [] args)\n   {\n      CheckingAccount c = new CheckingAccount(101);\n      System.out.println(\"Depositing $500...\");\n      c.deposit(500.00);\n      \n      try\n      {\n         System.out.println(\"\\nWithdrawing $100...\");\n         c.withdraw(100.00);\n         System.out.println(\"\\nWithdrawing $600...\");\n         c.withdraw(600.00);\n      }catch(InsufficientFundsException e)\n      {\n         System.out.println(\"Sorry, but you are short $\" + e.getAmount());\n         e.printStackTrace();\n      }\n    }\n}\nCompile all the above three files and run BankDemo, this would produce the following result:\n\nDepositing $500...\n\nWithdrawing $100...\n\nWithdrawing $600...\nSorry, but you are short $200.0\nInsufficientFundsException\n        at CheckingAccount.withdraw(CheckingAccount.java:25)\n        at BankDemo.main(BankDemo.java:13)\nCommon Exceptions:\nIn Java, it is possible to define two catergories of Exceptions and Errors.\n\nJVM Exceptions: - These are exceptions/errors that are exclusively or logically thrown by the JVM. Examples : NullPointerException, ArrayIndexOutOfBoundsException, ClassCastException,\n\nProgrammatic exceptions: - These exceptions are thrown explicitly by the application or the API programmers Examples: IllegalArgumentException, IllegalStateException.");
        jScrollPane7.setViewportView(jTextArea7);

        javax.swing.GroupLayout jPanel7Layout = new javax.swing.GroupLayout(jPanel7);
        jPanel7.setLayout(jPanel7Layout);
        jPanel7Layout.setHorizontalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane7, javax.swing.GroupLayout.DEFAULT_SIZE, 1088, Short.MAX_VALUE))
        );
        jPanel7Layout.setVerticalGroup(
            jPanel7Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel7Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane7, javax.swing.GroupLayout.DEFAULT_SIZE, 445, Short.MAX_VALUE))
        );

        jTabbedPane2.addTab("Exceptions ", jPanel7);

        jTextArea8.setColumns(20);
        jTextArea8.setRows(5);
        jTextArea8.setText("In the previous chapter, we talked about super classes and sub classes. If a class inherits a method from its super class, then there is a chance to override the method provided that it is not marked final.\n\nThe benefit of overriding is: ability to define a behaviour that's specific to the subclass type which means a subclass can implement a parent class method based on its requirement.\n\nIn object-oriented terms, overriding means to override the functionality of an existing method.\n\nExample:\nLet us look at an example.\n\nclass Animal{\n\n   public void move(){\n      System.out.println(\"Animals can move\");\n   }\n}\n\nclass Dog extends Animal{\n\n   public void move(){\n      System.out.println(\"Dogs can walk and run\");\n   }\n}\n\npublic class TestDog{\n\n   public static void main(String args[]){\n      Animal a = new Animal(); // Animal reference and object\n      Animal b = new Dog(); // Animal reference but Dog object\n\n      a.move();// runs the method in Animal class\n\n      b.move();//Runs the method in Dog class\n   }\n}\nThis would produce the following result:\n\nAnimals can move\nDogs can walk and run\nIn the above example, you can see that the even though b is a type of Animal it runs the move method in the Dog class. The reason for this is: In compile time, the check is made on the reference type. However, in the runtime, JVM figures out the object type and would run the method that belongs to that particular object.\n\nTherefore, in the above example, the program will compile properly since Animal class has the method move. Then, at the runtime, it runs the method specific for that object.\n\nConsider the following example :\n\nclass Animal{\n\n   public void move(){\n      System.out.println(\"Animals can move\");\n   }\n}\n\nclass Dog extends Animal{\n\n   public void move(){\n      System.out.println(\"Dogs can walk and run\");\n   }\n   public void bark(){\n      System.out.println(\"Dogs can bark\");\n   }\n}\n\npublic class TestDog{\n\n   public static void main(String args[]){\n      Animal a = new Animal(); // Animal reference and object\n      Animal b = new Dog(); // Animal reference but Dog object\n\n      a.move();// runs the method in Animal class\n      b.move();//Runs the method in Dog class\n      b.bark();\n   }\n}\nThis would produce the following result:\n\nTestDog.java:30: cannot find symbol\nsymbol  : method bark()\nlocation: class Animal\n                b.bark();\n                 ^\nThis program will throw a compile time error since b's reference type Animal doesn't have a method by the name of bark.\n\nRules for method overriding:\nThe argument list should be exactly the same as that of the overridden method.\n\nThe return type should be the same or a subtype of the return type declared in the original overridden method in the superclass.\n\nThe access level cannot be more restrictive than the overridden method's access level. For example: if the superclass method is declared public then the overridding method in the sub class cannot be either private or protected.\n\nInstance methods can be overridden only if they are inherited by the subclass.\n\nA method declared final cannot be overridden.\n\nA method declared static cannot be overridden but can be re-declared.\n\nIf a method cannot be inherited, then it cannot be overridden.\n\nA subclass within the same package as the instance's superclass can override any superclass method that is not declared private or final.\n\nA subclass in a different package can only override the non-final methods declared public or protected.\n\nAn overriding method can throw any uncheck exceptions, regardless of whether the overridden method throws exceptions or not. However the overriding method should not throw checked exceptions that are new or broader than the ones declared by the overridden method. The overriding method can throw narrower or fewer exceptions than the overridden method.\n\nConstructors cannot be overridden.\n\nUsing the super keyword:\nWhen invoking a superclass version of an overridden method the super keyword is used.\n\nclass Animal{\n\n   public void move(){\n      System.out.println(\"Animals can move\");\n   }\n}\n\nclass Dog extends Animal{\n\n   public void move(){\n      super.move(); // invokes the super class method\n      System.out.println(\"Dogs can walk and run\");\n   }\n}\n\npublic class TestDog{\n\n   public static void main(String args[]){\n\n      Animal b = new Dog(); // Animal reference but Dog object\n      b.move(); //Runs the method in Dog class\n\n   }\n}\nThis would produce the following result:\n\nAnimals can move\nDogs can walk and run");
        jScrollPane8.setViewportView(jTextArea8);

        javax.swing.GroupLayout jPanel9Layout = new javax.swing.GroupLayout(jPanel9);
        jPanel9.setLayout(jPanel9Layout);
        jPanel9Layout.setHorizontalGroup(
            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel9Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane8, javax.swing.GroupLayout.DEFAULT_SIZE, 1078, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel9Layout.setVerticalGroup(
            jPanel9Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel9Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane8, javax.swing.GroupLayout.DEFAULT_SIZE, 445, Short.MAX_VALUE))
        );

        jTabbedPane2.addTab("overriding", jPanel9);

        jTextArea9.setColumns(20);
        jTextArea9.setRows(5);
        jTextArea9.setText("Polymorphism is the ability of an object to take on many forms. The most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class object.\n\nAny Java object that can pass more than one IS-A test is considered to be polymorphic. In Java, all Java objects are polymorphic since any object will pass the IS-A test for their own type and for the class Object.\n\nIt is important to know that the only possible way to access an object is through a reference variable. A reference variable can be of only one type. Once declared, the type of a reference variable cannot be changed.\n\nThe reference variable can be reassigned to other objects provided that it is not declared final. The type of the reference variable would determine the methods that it can invoke on the object.\n\nA reference variable can refer to any object of its declared type or any subtype of its declared type. A reference variable can be declared as a class or interface type.\n\nExample:\nLet us look at an example.\n\npublic interface Vegetarian{}\npublic class Animal{}\npublic class Deer extends Animal implements Vegetarian{}\nNow, the Deer class is considered to be polymorphic since this has multiple inheritance. Following are true for the above example:\n\nA Deer IS-A Animal\n\nA Deer IS-A Vegetarian\n\nA Deer IS-A Deer\n\nA Deer IS-A Object\n\nWhen we apply the reference variable facts to a Deer object reference, the following declarations are legal:\n\nDeer d = new Deer();\nAnimal a = d;\nVegetarian v = d;\nObject o = d;\nAll the reference variables d,a,v,o refer to the same Deer object in the heap.\n\nVirtual Methods:\nIn this section, I will show you how the behaviour of overridden methods in Java allows you to take advantage of polymorphism when designing your classes.\n\nWe already have discussed method overriding, where a child class can override a method in its parent. An overridden method is essentially hidden in the parent class, and is not invoked unless the child class uses the super keyword within the overriding method.\n\n/* File name : Employee.java */\npublic class Employee\n{\n   private String name;\n   private String address;\n   private int number;\n   public Employee(String name, String address, int number)\n   {\n      System.out.println(\"Constructing an Employee\");\n      this.name = name;\n      this.address = address;\n      this.number = number;\n   }\n   public void mailCheck()\n   {\n      System.out.println(\"Mailing a check to \" + this.name\n       + \" \" + this.address);\n   }\n   public String toString()\n   {\n      return name + \" \" + address + \" \" + number;\n   }\n   public String getName()\n   {\n      return name;\n   }\n   public String getAddress()\n   {\n      return address;\n   }\n   public void setAddress(String newAddress)\n   {\n      address = newAddress;\n   }\n   public int getNumber()\n   {\n     return number;\n   }\n}\nNow suppose we extend Employee class as follows:\n\n/* File name : Salary.java */\npublic class Salary extends Employee\n{\n   private double salary; //Annual salary\n   public Salary(String name, String address, int number, double\n      salary)\n   {\n       super(name, address, number);\n       setSalary(salary);\n   }\n   public void mailCheck()\n   {\n       System.out.println(\"Within mailCheck of Salary class \");\n       System.out.println(\"Mailing check to \" + getName()\n       + \" with salary \" + salary);\n   }\n   public double getSalary()\n   {\n       return salary;\n   }\n   public void setSalary(double newSalary)\n   {\n       if(newSalary >= 0.0)\n       {\n          salary = newSalary;\n       }\n   }\n   public double computePay()\n   {\n      System.out.println(\"Computing salary pay for \" + getName());\n      return salary/52;\n   }\n}\nNow, you study the following program carefully and try to determine its output:\n\n/* File name : VirtualDemo.java */\npublic class VirtualDemo\n{\n   public static void main(String [] args)\n   {\n      Salary s = new Salary(\"Mohd Mohtashim\", \"Ambehta, UP\", 3, 3600.00);\n      Employee e = new Salary(\"John Adams\", \"Boston, MA\", 2, 2400.00);\n      System.out.println(\"Call mailCheck using Salary reference --\");\n      s.mailCheck();\n      System.out.println(\"\\n Call mailCheck using Employee reference--\");\n      e.mailCheck();\n    }\n}\nThis would produce the following result:\n\nConstructing an Employee\nConstructing an Employee\nCall mailCheck using Salary reference --\nWithin mailCheck of Salary class\nailing check to Mohd Mohtashim with salary 3600.0\n\nCall mailCheck using Employee reference--\nWithin mailCheck of Salary class\nailing check to John Adams with salary 2400.0\nHere, we instantiate two Salary objects . one using a Salary reference s, and the other using an Employee reference e.\n\nWhile invoking s.mailCheck() the compiler sees mailCheck() in the Salary class at compile time, and the JVM invokes mailCheck() in the Salary class at run time.\n\nInvoking mailCheck() on e is quite different because e is an Employee reference. When the compiler sees e.mailCheck(), the compiler sees the mailCheck() method in the Employee class.\n\nHere, at compile time, the compiler used mailCheck() in Employee to validate this statement. At run time, however, the JVM invokes mailCheck() in the Salary class.\n\nThis behavior is referred to as virtual method invocation, and the methods are referred to as virtual methods. All methods in Java behave in this manner, whereby an overridden method is invoked at run time, no matter what data type the reference is that was used in the source code at compile time.");
        jScrollPane9.setViewportView(jTextArea9);

        javax.swing.GroupLayout jPanel10Layout = new javax.swing.GroupLayout(jPanel10);
        jPanel10.setLayout(jPanel10Layout);
        jPanel10Layout.setHorizontalGroup(
            jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel10Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane9, javax.swing.GroupLayout.DEFAULT_SIZE, 1078, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel10Layout.setVerticalGroup(
            jPanel10Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel10Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane9, javax.swing.GroupLayout.DEFAULT_SIZE, 434, Short.MAX_VALUE)
                .addContainerGap())
        );

        jTabbedPane2.addTab("Polymorphism", jPanel10);

        jTextArea10.setColumns(20);
        jTextArea10.setRows(5);
        jTextArea10.setText("Abstract Class\nA class which contains the abstract keyword in its declaration is known as abstract class.\n\nAbstract classes may or may not contain abstract methods ie., methods with out body ( public void get(); )\n\nBut, if a class have at least one abstract method, then the class must be declared abstract.\n\nIf a class is declared abstract it cannot be instantiated.\n\nTo use an abstract class you have to inherit it from another class, provide implementations to the abstract methods in it.\n\nIf you inherit an abstract class you have to provide implementations to all the abstract methods in it.\n\nExample\nThis section provides you an example of the abstract class to create an abstract class just use the abstract keyword before the class keyword, in the class declaration .\n/* File name : Employee.java */\npublic abstract class Employee\n{\n   private String name;\n   private String address;\n   private int number;\n   public Employee(String name, String address, int number)\n   {\n      System.out.println(\"Constructing an Employee\");\n      this.name = name;\n      this.address = address;\n      this.number = number;\n   }\n   public double computePay()\n   {\n     System.out.println(\"Inside Employee computePay\");\n     return 0.0;\n   }\n   public void mailCheck()\n   {\n      System.out.println(\"Mailing a check to \" + this.name\n       + \" \" + this.address);\n   }\n   public String toString()\n   {\n      return name + \" \" + address + \" \" + number;\n   }\n   public String getName()\n   {\n      return name;\n   }\n   public String getAddress()\n   {\n      return address;\n   }\n   public void setAddress(String newAddress)\n   {\n      address = newAddress;\n   }\n   public int getNumber()\n   {\n     return number;\n   }\n}\nYou can observe that except abstract methods the Employee class is same as normal class in Java. The class is now abstract, but it still has three fields, seven methods, and one constructor.\n\nNow you can try to instantiate the Employee class as shown below:\n\n/* File name : AbstractDemo.java */\npublic class AbstractDemo\n{\n   public static void main(String [] args)\n   {\n      /* Following is not allowed and would raise error */\n      Employee e = new Employee(\"George W.\", \"Houston, TX\", 43);\n\n      System.out.println(\"\\n Call mailCheck using Employee reference--\");\n      e.mailCheck();\n    }\n}\nWhen you compile the above class, it gives you the following error:\n\nEmployee.java:46: Employee is abstract; cannot be instantiated\n      Employee e = new Employee(\"George W.\", \"Houston, TX\", 43);\n                   ^\n1 error\nInheriting the Abstract Class:\nWe can inherit the properties of Employee class just like concrete class as shown below:\n\n/* File name : Salary.java */\npublic class Salary extends Employee\n{\n   private double salary; //Annual salary\n   public Salary(String name, String address, int number, double\n      salary)\n   {\n       super(name, address, number);\n       setSalary(salary);\n   }\n   public void mailCheck()\n   {\n       System.out.println(\"Within mailCheck of Salary class \");\n       System.out.println(\"Mailing check to \" + getName()\n       + \" with salary \" + salary);\n   }\n   public double getSalary()\n   {\n       return salary;\n   }\n   public void setSalary(double newSalary)\n   {\n       if(newSalary >= 0.0)\n       {\n          salary = newSalary;\n       }\n   }\n   public double computePay()\n   {\n      System.out.println(\"Computing salary pay for \" + getName());\n      return salary/52;\n   }\n}\nHere, you cannot instantiate the Employee class, but you can instantiate the Salary Class, and using this instance you can access the all the three fields and seven methods of Employee class as shown below.\n\n/* File name : AbstractDemo.java */\npublic class AbstractDemo\n{\n   public static void main(String [] args)\n   {\n      Salary s = new Salary(\"Mohd Mohtashim\", \"Ambehta, UP\", 3, 3600.00);\n      Employee e = new Salary(\"John Adams\", \"Boston, MA\", 2, 2400.00);\n\n      System.out.println(\"Call mailCheck using Salary reference --\");\n      s.mailCheck();\n\n      System.out.println(\"\\n Call mailCheck using Employee reference--\");\n      e.mailCheck();\n    }\n}\nThis produces the following result:\n\nConstructing an Employee\nConstructing an Employee\nCall mailCheck using  Salary reference --\nWithin mailCheck of Salary class\nailing check to Mohd Mohtashim with salary 3600.0\n\nCall mailCheck using Employee reference--\nWithin mailCheck of Salary class\nailing check to John Adams with salary 2400.\nAbstract Methods:\nIf you want a class to contain a particular method but you want the actual implementation of that method to be determined by child classes, you can declare the method in the parent class as abstract.\n\nabstract keyword is used to declare the method as abstract.\n\nYou have to place the abstract keyword before the method name in the method declaration.\n\nAn abstract method contains a method signature, but no method body.\n\nInstead of curly braces an abstract method will have a semoi colon ( ; ) at the end.\n\nBelow given is an example of the abstract method.\n\npublic abstract class Employee\n{\n   private String name;\n   private String address;\n   private int number;\n   \n   public abstract double computePay();\n   \n   //Remainder of class definition\n}\nDeclaring a method as abstract has two consequences:\n\nThe class containing it must be declared as abstract.\n\nAny class inheriting the current class must either override the abstract method or declare itself as abstract.\n\nNote: Eventually, a descendant class has to implement the abstract method; otherwise, you would have a hierarchy of abstract classes that cannot be instantiated.\n\nSuppose Salary class is inherits the Employee class, then it should implement the computePay() method as shown below:\n\n/* File name : Salary.java */\npublic class Salary extends Employee\n{\n   private double salary; // Annual salary\n  \n   public double computePay()\n   {\n      System.out.println(\"Computing salary pay for \" + getName());\n      return salary/52;\n   }\n\n   //Remainder of class definition\n}\n\nEncapsulation is one of the four fundamental OOP concepts. The other three are inheritance, polymorphism, and abstraction.\n\nEncapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as as single unit. In encapsulation the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class, therefore it is also known as data hiding.\n\nTo achieve encapsulation in Java\n\nDeclare the variables of a class as private.\n\nProvide public setter and getter methods to modify and view the variables values.\n\nExample:\nBelow given is an example that demonstrates how to achieve Encapsulation in Java:\n\n/* File name : EncapTest.java */\npublic class EncapTest{\n\n   private String name;\n   private String idNum;\n   private int age;\n\n   public int getAge(){\n      return age;\n   }\n\n   public String getName(){\n      return name;\n   }\n\n   public String getIdNum(){\n      return idNum;\n   }\n\n   public void setAge( int newAge){\n      age = newAge;\n   }\n\n   public void setName(String newName){\n      name = newName;\n   }\n\n   public void setIdNum( String newId){\n      idNum = newId;\n   }\n}\nThe public setXXX() and getXXX() methods are the access points of the instance variables of the EncapTest class. Normally, these methods are referred as getters and setters. Therefore any class that wants to access the variables should access them through these getters and setters.\n\nThe variables of the EncapTest class can be accessed as below::\n\n/* File name : RunEncap.java */\npublic class RunEncap{\n\n   public static void main(String args[]){\n      EncapTest encap = new EncapTest();\n      encap.setName(\"James\");\n      encap.setAge(20);\n      encap.setIdNum(\"12343ms\");\n\n      System.out.print(\"Name : \" + encap.getName() + \" Age : \" + encap.getAge());\n    }\n}\nThis would produce the following result:\n\nName : James Age : 20\nBenefits of Encapsulation:\nThe fields of a class can be made read-only or write-only.\n\nA class can have total control over what is stored in its fields.\n\nThe users of a class do not know how the class stores its data. A class can change the data type of a field and users of the class do not need to change any of their code.");
        jScrollPane10.setViewportView(jTextArea10);

        javax.swing.GroupLayout jPanel11Layout = new javax.swing.GroupLayout(jPanel11);
        jPanel11.setLayout(jPanel11Layout);
        jPanel11Layout.setHorizontalGroup(
            jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel11Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane10, javax.swing.GroupLayout.DEFAULT_SIZE, 1078, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel11Layout.setVerticalGroup(
            jPanel11Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel11Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane10, javax.swing.GroupLayout.DEFAULT_SIZE, 445, Short.MAX_VALUE))
        );

        jTabbedPane2.addTab("Abstraction & Encapsulation", jPanel11);

        jTextArea11.setColumns(20);
        jTextArea11.setRows(5);
        jTextArea11.setText("An interface is a reference type in Java, it is similar to class, it is a collection of abstract methods. A class implements an interface, thereby inheriting the abstract methods of the interface.\n\nAlong with abstract methods an interface may also contain constants, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods.\n\nWriting an interface is similar to writing a class. But a class describes the attributes and behaviours of an object. And an interface contains behaviours that a class implements.\n\nUnless the class that implements the interface is abstract, all the methods of the interface need to be defined in the class.\n\nAn interface is similar to a class in the following ways:\n\nAn interface can contain any number of methods.\n\nAn interface is written in a file with a .java extension, with the name of the interface matching the name of the file.\n\nThe byte code of an interface appears in a .class file.\n\nInterfaces appear in packages, and their corresponding bytecode file must be in a directory structure that matches the package name.\n\nHowever, an interface is different from a class in several ways, including:\n\nYou cannot instantiate an interface.\n\nAn interface does not contain any constructors.\n\nAll of the methods in an interface are abstract.\n\nAn interface cannot contain instance fields. The only fields that can appear in an interface must be declared both static and final.\n\nAn interface is not extended by a class; it is implemented by a class.\n\nAn interface can extend multiple interfaces.\n\nDeclaring Interfaces:\nThe interface keyword is used to declare an interface. Here is a simple example to declare an interface:\n\nExample:\nBelow given is an example of an interface:\n\n/* File name : NameOfInterface.java */\nimport java.lang.*;\n//Any number of import statements\n\npublic interface NameOfInterface\n{\n   //Any number of final, static fields\n   //Any number of abstract method declarations\\\n}\nInterfaces have the following properties:\n\nAn interface is implicitly abstract. You do not need to use the abstract keyword while declaring an interface.\n\nEach method in an interface is also implicitly abstract, so the abstract keyword is not needed.\n\nMethods in an interface are implicitly public.\n\nExample:\n/* File name : Animal.java */\ninterface Animal {\n\n   public void eat();\n   public void travel();\n}\nImplementing Interfaces:\nWhen a class implements an interface, you can think of the class as signing a contract, agreeing to perform the specific behaviors of the interface. If a class does not perform all the behaviors of the interface, the class must declare itself as abstract.\n\nA class uses the implements keyword to implement an interface. The implements keyword appears in the class declaration following the extends portion of the declaration.\n\n/* File name : MammalInt.java */\npublic class MammalInt implements Animal{\n\n   public void eat(){\n      System.out.println(\"Mammal eats\");\n   }\n\n   public void travel(){\n      System.out.println(\"Mammal travels\");\n   } \n\n   public int noOfLegs(){\n      return 0;\n   }\n\n   public static void main(String args[]){\n      MammalInt m = new MammalInt();\n      m.eat();\n      m.travel();\n   }\n} \nThis would produce the following result:\n\nammal eats\nammal travels\nWhen overriding methods defined in interfaces there are several rules to be followed:\n\nChecked exceptions should not be declared on implementation methods other than the ones declared by the interface method or subclasses of those declared by the interface method.\n\nThe signature of the interface method and the same return type or subtype should be maintained when overriding the methods.\n\nAn implementation class itself can be abstract and if so interface methods need not be implemented.\n\nWhen implementation interfaces there are several rules:\n\nA class can implement more than one interface at a time.\n\nA class can extend only one class, but implement many interfaces.\n\nAn interface can extend another interface, similarly to the way that a class can extend another class.\n\nExtending Interfaces:\nAn interface can extend another interface, similarly to the way that a class can extend another class. The extends keyword is used to extend an interface, and the child interface inherits the methods of the parent interface.\n\nThe following Sports interface is extended by Hockey and Football interfaces.\n\n//Filename: Sports.java\npublic interface Sports\n{\n   public void setHomeTeam(String name);\n   public void setVisitingTeam(String name);\n}\n\n//Filename: Football.java\npublic interface Football extends Sports\n{\n   public void homeTeamScored(int points);\n   public void visitingTeamScored(int points);\n   public void endOfQuarter(int quarter);\n}\n\n//Filename: Hockey.java\npublic interface Hockey extends Sports\n{\n   public void homeGoalScored();\n   public void visitingGoalScored();\n   public void endOfPeriod(int period);\n   public void overtimePeriod(int ot);\n}\nThe Hockey interface has four methods, but it inherits two from Sports; thus, a class that implements Hockey needs to implement all six methods. Similarly, a class that implements Football needs to define the three methods from Football and the two methods from Sports.\n\nExtending Multiple Interfaces:\nA Java class can only extend one parent class. Multiple inheritance is not allowed. Interfaces are not classes, however, and an interface can extend more than one parent interface.\n\nThe extends keyword is used once, and the parent interfaces are declared in a comma-separated list.\n\nFor example, if the Hockey interface extended both Sports and Event, it would be declared as:\n\npublic interface Hockey extends Sports, Event\nTagging Interfaces:\nThe most common use of extending interfaces occurs when the parent interface does not contain any methods. For example, the MouseListener interface in the java.awt.event package extended java.util.EventListener, which is defined as:\n\npackage java.util;\npublic interface EventListener\n{}\nAn interface with no methods in it is referred to as a tagging interface. There are two basic design purposes of tagging interfaces:\n\nCreates a common parent: As with the EventListener interface, which is extended by dozens of other interfaces in the Java API, you can use a tagging interface to create a common parent among a group of interfaces. For example, when an interface extends EventListener, the JVM knows that this particular interface is going to be used in an event delegation scenario.\n\nAdds a data type to a class: This situation is where the term tagging comes from. A class that implements a tagging interface does not need to define any methods (since the interface does not have any), but the class becomes an interface type through polymorphism.\n\nPackages are used in Java in order to prevent naming conflicts, to control access, to make searching/locating and usage of classes, interfaces, enumerations and annotations easier, etc.\n\nA Package can be defined as a grouping of related types (classes, interfaces, enumerations and annotations ) providing access protection and name space management.\n\nSome of the existing packages in Java are::\n\njava.lang - bundles the fundamental classes\n\njava.io - classes for input , output functions are bundled in this package\n\nProgrammers can define their own packages to bundle group of classes/interfaces, etc. It is a good practice to group related classes implemented by you so that a programmer can easily determine that the classes, interfaces, enumerations, annotations are related.\n\nSince the package creates a new namespace there won't be any name conflicts with names in other packages. Using packages, it is easier to provide access control and it is also easier to locate the related classes.\n\nCreating a package:\nWhile creating a package, you should choose a name for the package and include a package statement along with that name at the top of every source file that contains the classes, interfaces, enumerations, and annotation types that you want to include in the package.\n\nThe package statement should be the first line in the source file. There can be only one package statement in each source file, and it applies to all types in the file.\n\nIf a package statement is not used then the class, interfaces, enumerations, and annotation types will be placed in the current default package.\n\nTo compile the Java programs with package statements you have to do use -d option as shown below.\n\njavac -d Destination_folder file_name.java\nThen a folder with the given package name is created in the specified destination, and the compiled class files will be placed in that folder\n\nExample:\nLet us look at an example that creates a package called animals. It is a good practice to use names of packages with lower case letters to avoid any conflicts with the names of classes, interfaces.\n\nBelow given package example contains interface named animals:\n\n/* File name : Animal.java */\npackage animals;\ninterface Animal {\n   public void eat();\n   public void travel();\n}\nNow, let us implement the above interface in the same package animals:\n\npackage animals;\n\n/* File name : MammalInt.java */\npublic class MammalInt implements Animal{\n\n   public void eat(){\n      System.out.println(\"Mammal eats\");\n   }\n\n   public void travel(){\n      System.out.println(\"Mammal travels\");\n   } \n\n   public int noOfLegs(){\n      return 0;\n   }\n\n   public static void main(String args[]){\n      MammalInt m = new MammalInt();\n      m.eat();\n      m.travel();\n   }\n} \nNow compile the java files as shown below:\n\n$ javac -d . Animal.java \n$ javac -d . MammalInt.java\nNow a package/folder with the name animals will be created in the current directory and these class files will be placed in it as shown below.\n\ntutorialspoint\n \n\nYou can execute the class file with in the package and get the result as shown below.\n\n$ java animals.MammalInt\nammal eats\nammal travels\nThe import Keyword:\nIf a class wants to use another class in the same package, the package name does not need to be used. Classes in the same package find each other without any special syntax.\n\nExample:\nHere, a class named Boss is added to the payroll package that already contains Employee. The Boss can then refer to the Employee class without using the payroll prefix, as demonstrated by the following Boss class.\n\npackage payroll;\n\npublic class Boss\n{\n   public void payEmployee(Employee e)\n   {\n      e.mailCheck();\n   }\n}\nWhat happens if the Employee class is not in the payroll package? The Boss class must then use one of the following techniques for referring to a class in a different package.\n\nThe fully qualified name of the class can be used. For example:\n\npayroll.Employee\nThe package can be imported using the import keyword and the wild card (*). For example:\n\nimport payroll.*;\nThe class itself can be imported using the import keyword. For example:\n\nimport payroll.Employee;\nNote: A class file can contain any number of import statements. The import statements must appear after the package statement and before the class declaration.\n\nThe Directory Structure of Packages:\nTwo major results occur when a class is placed in a package:\n\nThe name of the package becomes a part of the name of the class, as we just discussed in the previous section.\n\nThe name of the package must match the directory structure where the corresponding bytecode resides.\n\nHere is simple way of managing your files in Java:\n\nPut the source code for a class, interface, enumeration, or annotation type in a text file whose name is the simple name of the type and whose extension is .java. For example:\n\n// File Name :  Car.java\n\npackage vehicle;\n\npublic class Car {\n   // Class implementation.   \n}\nNow, put the source file in a directory whose name reflects the name of the package to which the class belongs:\n\n....\\vehicle\\Car.java\nNow, the qualified class name and pathname would be as below:\n\nClass name -> vehicle.Car\n\nPath name -> vehicle\\Car.java (in windows)\n\nIn general, a company uses its reversed Internet domain name for its package names. Example: A company's Internet domain name is apple.com, then all its package names would start with com.apple. Each component of the package name corresponds to a subdirectory.\n\nExample: The company had a com.apple.computers package that contained a Dell.java source file, it would be contained in a series of subdirectories like this:\n\n....\\com\\apple\\computers\\Dell.java\nAt the time of compilation, the compiler creates a different output file for each class, interface and enumeration defined in it. The base name of the output file is the name of the type, and its extension is .class\n\nFor example:\n\n// File Name: Dell.java\n\npackage com.apple.computers;\npublic class Dell{\n      \n}\nclass Ups{\n      \n}\nNow, compile this file as follows using -d option:\n\n$javac -d . Dell.java\nThis would put compiled files as follows:\n\n.\\com\\apple\\computers\\Dell.class\n.\\com\\apple\\computers\\Ups.class\nYou can import all the classes or interfaces defined in \\com\\apple\\computers\\ as follows:\n\nimport com.apple.computers.*;\nLike the .java source files, the compiled .class files should be in a series of directories that reflect the package name. However, the path to the .class files does not have to be the same as the path to the .java source files. You can arrange your source and class directories separately, as:\n\n<path-one>\\sources\\com\\apple\\computers\\Dell.java\n\n<path-two>\\classes\\com\\apple\\computers\\Dell.class\nBy doing this, it is possible to give the classes directory to other programmers without revealing your sources. You also need to manage source and class files in this manner so that the compiler and the Java Virtual Machine (JVM) can find all the types your program uses.\n\nThe full path to the classes directory, <path-two>\\classes, is called the class path, and is set with the CLASSPATH system variable. Both the compiler and the JVM construct the path to your .class files by adding the package name to the class path.\n\nSay <path-two>\\classes is the class path, and the package name is com.apple.computers, then the compiler and JVM will look for .class files in <path-two>\\classes\\com\\apple\\compters.\n\nA class path may include several paths. Multiple paths should be separated by a semicolon (Windows) or colon (Unix). By default, the compiler and the JVM search the current directory and the JAR file containing the Java platform classes so that these directories are automatically in the class path.\n\nSet CLASSPATH System Variable:\nTo display the current CLASSPATH variable, use the following commands in Windows and UNIX (Bourne shell):\n\nIn Windows -> C:\\> set CLASSPATH\n\nIn UNIX -> % echo $CLASSPATH\n\nTo delete the current contents of the CLASSPATH variable, use :\n\nIn Windows -> C:\\> set CLASSPATH=\n\nIn UNIX -> % unset CLASSPATH; export CLASSPATH\n\nTo set the CLASSPATH variable:\n\nIn Windows -> set CLASSPATH=C:\\users\\jack\\java\\classes\n\nIn UNIX -> % CLASSPATH=/home/jack/java/classes; export CLASSPATH");
        jScrollPane11.setViewportView(jTextArea11);

        javax.swing.GroupLayout jPanel12Layout = new javax.swing.GroupLayout(jPanel12);
        jPanel12.setLayout(jPanel12Layout);
        jPanel12Layout.setHorizontalGroup(
            jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel12Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane11, javax.swing.GroupLayout.DEFAULT_SIZE, 1078, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel12Layout.setVerticalGroup(
            jPanel12Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel12Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane11, javax.swing.GroupLayout.DEFAULT_SIZE, 445, Short.MAX_VALUE))
        );

        jTabbedPane2.addTab("interfaces And packges", jPanel12);

        jTextArea12.setColumns(20);
        jTextArea12.setRows(5);
        jTextArea12.setText("Inheritance can be defined as the process where one class acquires the properties (methods and fields) of another. With the use of inheritance the information is made manageable in a hierarchical order.\n\nThe class which inherits the properties of other is known as subclass (derived class, child class) and the class whose properties are inherited is known as superclass (base class, parent class).\n\nextends Keyword\nextends is the keyword used to inherit the properties of a class. Below given is the syntax of extends keyword.\n\nclass Super{\n.....\n.....\n}\n\nclass Sub extends Super{\n.....\n.....\n\n}\nSample Code\nBelow given is an example demonstrating Java inheritance. In this example you can observe two classes namely Calculation and My_Calculation.\n\nUsing extends keyword the My_Calculation inherits the methods addition() and Subtraction() of Calculation class.\n\nCopy and paste the program given below in a file with name My_Calculation.java\n\nclass Calculation{ \n   int z;\n   public void addition(int x, int y){\n      z=x+y;\n      System.out.println(\"The sum of the given numbers:\"+z);\n   }\n   public void Substraction(int x,int y){\n      z=x-y;\n      System.out.println(\"The difference between the given numbers:\"+z);\n   }\n   \n}\n\npublic class My_Calculation extends Calculation{    \n  \n   public void multiplication(int x, int y){\n      z=x*y;\n      System.out.println(\"The product of the given numbers:\"+z);\n   }\n   public static void main(String args[]){\n      int a=20, b=10;\n      My_Calculation demo = new My_Calculation();\n      demo.addition(a, b);\n      demo.Substraction(a, b);\n      demo.multiplication(a, b);      \n      \n   }\n\n}\nCompile and execute the above code as shown below\n\njavac My_Calculation.java\njava My_Calculation\nAfter executing the program it will produce the following result.\n\nThe sum of the given numbers:30\nThe difference between the given numbers:10\nThe product of the given numbers:200\n \n\nIn the given program when an object to My_Calculation class is created, a copy of the contents of the super class is made with in it. That is why, using the object of the subclass you can access the members of a super class.\n\nInheritance\nThe Superclass reference variable can hold the subclass object, but using that variable you can access only the members of the superclass, so to access the members of both classes it is recommended to always create reference variable to the subclass.\n\nIf you consider the above program you can instantiate the class as given below as well. But using the superclass reference variable ( cal in this case ) you cannot call the method multiplication(), which belongs to the subclass My_Calculation.\n\nCalculation cal=new My_Calculation();\ndemo.addition(a, b);\ndemo.Subtraction(a, b);\nNote: A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.\n\nThe super keyword\nThe super keyword is similar to this keyword following are the scenarios where the super keyword is used.\n\nIt is used to differentiate the members of superclass from the members of subclass, if they have same names.\n\nIt is used to invoke the superclass constructor from subclass.\n\nDifferentiating the members\nIf a class is inheriting the properties of another class. And if the members of the superclass have the names same as the sub class, to differentiate these variables we use super keyword as shown below.\n\nsuper.variable\nsuper.method();\nSample Code\nThis section provides you a program that demonstrates the usage of the super keyword.\n\nIn the given program you have two classes namely Sub_class and Super_class, both have a method named display() with different implementations, and a variable named num with different values. We are invoking display() method of both classes and printing the value of the variable num of both classes, here you can observe that we have used super key word to differentiate the members of super class from sub class.\n\nCopy and paste the program in a file with name Sub_class.java.\n\nclass Super_class{\n\n   int num=20;\n   \n   //display method of superclass\n   public void display(){   \n      System.out.println(\"This is the display method of superclass\");\n   }\t\n\n}\n\npublic class Sub_class extends Super_class {\n\n   int num=10;\n   \n   //display method of sub class\n   public void display(){\n      System.out.println(\"This is the display method of subclass\");\n   }\n   \n   public void my_method(){\n\t  \n      //Instantiating subclass\n      Sub_class sub=new Sub_class();\n\t  \n      //Invoking the display() method of sub class\n      sub.display();\n\t  \n      //Invoking the display() method of superclass\n      super.display();\n\t  \n      //printing the value of variable num of subclass\n      System.out.println(\"value of the variable named num in sub class:\"+ sub.num);\n\t\t  \n      //printing the value of variable num of superclass\n      System.out.println(\"value of the variable named num in super class:\"+ super.num);     \n   }\n   \n   public static void main(String args[]){\n      Sub_class obj = new Sub_class();\n      obj.my_method();\n      \n   }\n}\nCompile and execute the above code using the following syntax.\n\njavac Super_Demo\njava Super\nOn executing the program you will get the following result:\n\nThis is the display method of subclass\nThis is the display method of superclass\nvalue of the variable named num in sub class:10\nvalue of the variable named num in super class:20\nInvoking Superclass constructor\nIf a class is inheriting the properties of another class, the subclass automatically acquires the default constructor of the super class. But if you want to call a parametrized constructor of the super class, you need to use the super keyword as shown below.\n\nsuper(values);\nSample Code\nThe program given in this section demonstrates how to use the super keyword to invoke the parametrized constructor of the superclass. This program contains a super class and a sub class, where the super class contains a parametrized constructor which accepts a string value, and we used the super keyword to invoke the parametrized constructor of the super class.\n\nCopy and paste the below given program in a file with name Subclass.java\n\nclass Superclass{\n   \n   int age;\n\n   Superclass(int age){\n      this.age=age; \t\t \n   }\n\n   public void getAge(){\n      System.out.println(\"The value of the variable named age in super class is: \" +age);\n   }\n\n}\n\npublic class Subclass extends Superclass {\n   \n   Subclass(int age){\n      super(age);\n   }\n\n   public static void main(String argd[]){\n      Subclass s= new Subclass(24);\n      s.getAge();\n   }\n\n}\nCompile and execute the above code using the following syntax.\n\njavac Subclass\njava Subclass\nOn executing the program you will get the following result:\n\nThe value of the variable named age in super class is: 24\nIS-A Relationship:\nIS-A is a way of saying : This object is a type of that object. Let us see how the extends keyword is used to achieve inheritance.\n\npublic class Animal{\n}\n\npublic class Mammal extends Animal{\n}\n\npublic class Reptile extends Animal{\n}\n\npublic class Dog extends Mammal{\n}\nNow, based on the above example, In Object Oriented terms, the following are true:\n\nAnimal is the superclass of Mammal class.\n\nAnimal is the superclass of Reptile class.\n\nMammal and Reptile are subclasses of Animal class.\n\nDog is the subclass of both Mammal and Animal classes.\n\nNow, if we consider the IS-A relationship, we can say:\n\nMammal IS-A Animal\n\nReptile IS-A Animal\n\nDog IS-A Mammal\n\nHence : Dog IS-A Animal as well\n\nWith use of the extends keyword the subclasses will be able to inherit all the properties of the superclass except for the private properties of the superclass.\n\nWe can assure that Mammal is actually an Animal with the use of the instance operator.\n\nExample\nclass Animal{\n}\n\nclass Mammal extends Animal{\n}\n\nclass Reptile extends Animal{\n}\n\npublic class Dog extends Mammal{\n\n   public static void main(String args[]){\n\n      Animal a = new Animal();\n      Mammal m = new Mammal();\n      Dog d = new Dog();\n\n      System.out.println(m instanceof Animal);\n      System.out.println(d instanceof Mammal);\n      System.out.println(d instanceof Animal);\n   }\n}\nThis would produce the following result:\n\ntrue\ntrue\ntrue\nSince we have a good understanding of the extends keyword let us look into how the implements keyword is used to get the IS-A relationship.\n\nThe implements keyword is used by classes by inherit from interfaces. Interfaces can never be extended by the classes.\n\nExample\npublic interface Animal {\n}\n\npublic class Mammal implements Animal{\n}\n\npublic class Dog extends Mammal{\n}\nThe instanceof Keyword\nLet us use the instanceof operator to check determine whether Mammal is actually an Animal, and dog is actually an Animal\n\ninterface Animal{}\n\nclass Mammal implements Animal{}\n\npublic class Dog extends Mammal{\n   public static void main(String args[]){\n\n      Mammal m = new Mammal();\n      Dog d = new Dog();\n\n      System.out.println(m instanceof Animal);\n      System.out.println(d instanceof Mammal);\n      System.out.println(d instanceof Animal);\n   }\n} \nThis would produce the following result:\n\ntrue\ntrue\ntrue\nHAS-A relationship\nThese relationships are mainly based on the usage. This determines whether a certain class HAS-A certain thing. This relationship helps to reduce duplication of code as well as bugs.\n\nLets us look into an example:\n\npublic class Vehicle{}\npublic class Speed{}\npublic class Van extends Vehicle{\n\tprivate Speed sp;\n} \nThis shows that class Van HAS-A Speed. By having a separate class for Speed, we do not have to put the entire code that belongs to speed inside the Van class., which makes it possible to reuse the Speed class in multiple applications.\n\nIn Object-Oriented feature, the users do not need to bother about which object is doing the real work. To achieve this, the Van class hides the implementation details from the users of the Van class. So basically what happens is the users would ask the Van class to do a certain action and the Van class will either do the work by itself or ask another class to perform the action.\n\nTypes of inheritance\nThere are various types of inheritance as demonstrated below.\n\nJava Tutorial\nA very important fact to remember is that Java does not support multiple inheritance. This means that a class cannot extend more than one class. Therefore following is illegal:\n\npublic class extends Animal, Mammal{} \nHowever, a class can implement one or more interfaces. This has made Java get rid of the impossibility of multiple inheritance.");
        jScrollPane12.setViewportView(jTextArea12);

        javax.swing.GroupLayout jPanel8Layout = new javax.swing.GroupLayout(jPanel8);
        jPanel8.setLayout(jPanel8Layout);
        jPanel8Layout.setHorizontalGroup(
            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel8Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane12, javax.swing.GroupLayout.DEFAULT_SIZE, 1078, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel8Layout.setVerticalGroup(
            jPanel8Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel8Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane12, javax.swing.GroupLayout.DEFAULT_SIZE, 445, Short.MAX_VALUE))
        );

        jTabbedPane2.addTab("inheritance", jPanel8);

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jTextArea1.setText("Java programming language was originally developed by Sun Microsystems which was initiated by James Gosling and released in 1995 as core component of Sun Microsystems' Java platform (Java 1.0 [J2SE]).\n\nThe latest release of the Java Standard Edition is Java SE 8. With the advancement of Java and its widespread popularity, multiple configurations were built to suite various types of platforms. Ex: J2EE for Enterprise Applications, J2ME for Mobile Applications.\n\nThe new J2 versions were renamed as Java SE, Java EE and Java ME respectively. Java is guaranteed to be Write Once, Run Anywhere.\n\nJava is:\n\nObject Oriented: In Java, everything is an Object. Java can be easily extended since it is based on the Object model.\n\nPlatform independent: Unlike many other programming languages including C and C++, when Java is compiled, it is not compiled into platform specific machine, rather into platform independent byte code. This byte code is distributed over the web and interpreted by virtual Machine (JVM) on whichever platform it is being run.\n\nSimple: Java is designed to be easy to learn. If you understand the basic concept of OOP Java would be easy to master.\n\nSecure: With Java's secure feature it enables to develop virus-free, tamper-free systems. Authentication techniques are based on public-key encryption.\n\nArchitectural-neutral: Java compiler generates an architecture-neutral object file format which makes the compiled code to be executable on many processors, with the presence of Java runtime system.\n\nPortable: Being architectural-neutral and having no implementation dependent aspects of the specification makes Java portable. Compiler in Java is written in ANSI C with a clean portability boundary which is a POSIX subset.\n\nRobust: Java makes an effort to eliminate error prone situations by emphasizing mainly on compile time error checking and runtime checking.\n\nMultithreaded: With Java's multithreaded feature it is possible to write programs that can do many tasks simultaneously. This design feature allows developers to construct smoothly running interactive applications.\n\nInterpreted: Java byte code is translated on the fly to native machine instructions and is not stored anywhere. The development process is more rapid and analytical since the linking is an incremental and light weight process.\n\nHigh Performance: With the use of Just-In-Time compilers, Java enables high performance.\n\nDistributed: Java is designed for the distributed environment of the internet.\n\nDynamic: Java is considered to be more dynamic than C or C++ since it is designed to adapt to an evolving environment. Java programs can carry extensive amount of run-time information that can be used to verify and resolve accesses to objects on run-time.\n\nHistory of Java:\nJames Gosling initiated the Java language project in June 1991 for use in one of his many set-top box projects. The language, initially called Oak after an oak tree that stood outside Gosling's office, also went by the name Green and ended up later being renamed as Java, from a list of random words.\n\nSun released the first public implementation as Java 1.0 in 1995. It promised Write Once, Run Anywhere(WORA), providing no-cost run-times on popular platforms.\n\nOn 13 November 2006, Sun released much of Java as free and open source software under the terms of the GNU General Public License (GPL).\n\nOn 8 May 2007, Sun finished the process, making all of Java's core code free and open-source, aside from a small portion of code to which Sun did not hold the copyright.\n\nTools you will need:\nFor performing the examples discussed in this tutorial, you will need a Pentium 200-MHz computer with a minimum of 64 MB of RAM (128 MB of RAM recommended).\n\nYou also will need the following softwares:\n\nLinux 7.1 or Windows xp/7/8 operating system.\n\nJava JDK 8\n\nMicrosoft Notepad or any other text editor\n\nThis tutorial will provide the necessary skills to create GUI, networking, and Web applications using Java.\n\nTry It Option:\nWe have provided you an option to compile and execute available code online. Just click on Try it button avaiable at top-right corner of the code window to compile and execute available code. There are certain examples which can not be executed online, so we have skipped those examples.\n\npublic class MyFirstJavaProgram {\n\n    public static void main(String []args) {\n       System.out.println(\"Hello World\");\n    }\n} \nThere may be a case that you do not see the result of the compiled/executed code, in such case you can re-try to compile and execute the code using execute button available in compliation pop-up window.");
        jScrollPane1.setViewportView(jTextArea1);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 1078, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 588, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jTabbedPane2.addTab("Introduction", jPanel1);

        jButton1.setText("back");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setText("exit");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton3.setText("Online Help");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 99, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1)
                        .addGap(18, 18, 18)
                        .addComponent(jButton2)
                        .addGap(33, 33, 33)
                        .addComponent(jButton3)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(jTabbedPane2, javax.swing.GroupLayout.Alignment.TRAILING))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButton1)
                    .addComponent(jButton2)
                    .addComponent(jButton3))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jTabbedPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 484, Short.MAX_VALUE)
                .addGap(18, 18, 18))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        JOptionPane.showMessageDialog(null,"Thank you for Visiting our developing Courseware.");
        System.exit(0);        // TODO add your handling code here:
    }//GEN-LAST:event_jButton2ActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        StudentMain a=new StudentMain();
        a.setVisible(true);
        setVisible(false);
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        /*        // TODO add your handling code here:*/
        String[] args= null;
        try {
            YoutubePlay.main(args);
        } catch (URISyntaxException ex) {
            Logger.getLogger(Courseware.class.getName()).log(Level.SEVERE, null, ex);
        }
        setVisible(false);
    }//GEN-LAST:event_jButton3ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Courseware.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Courseware.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Courseware.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Courseware.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Courseware().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel10;
    private javax.swing.JPanel jPanel11;
    private javax.swing.JPanel jPanel12;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JPanel jPanel8;
    private javax.swing.JPanel jPanel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane10;
    private javax.swing.JScrollPane jScrollPane11;
    private javax.swing.JScrollPane jScrollPane12;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JScrollPane jScrollPane7;
    private javax.swing.JScrollPane jScrollPane8;
    private javax.swing.JScrollPane jScrollPane9;
    private javax.swing.JTabbedPane jTabbedPane2;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea10;
    private javax.swing.JTextArea jTextArea11;
    private javax.swing.JTextArea jTextArea12;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JTextArea jTextArea3;
    private javax.swing.JTextArea jTextArea4;
    private javax.swing.JTextArea jTextArea5;
    private javax.swing.JTextArea jTextArea6;
    private javax.swing.JTextArea jTextArea7;
    private javax.swing.JTextArea jTextArea8;
    private javax.swing.JTextArea jTextArea9;
    // End of variables declaration//GEN-END:variables
}
