<?xml version="1.0" encoding="UTF-8" ?>

<Form version="1.8" maxVersion="1.9" type="org.netbeans.modules.form.forminfo.JFrameFormInfo">
  <Properties>
    <Property name="defaultCloseOperation" type="int" value="3"/>
  </Properties>
  <SyntheticProperties>
    <SyntheticProperty name="formSizePolicy" type="int" value="1"/>
    <SyntheticProperty name="generateCenter" type="boolean" value="false"/>
  </SyntheticProperties>
  <AuxValues>
    <AuxValue name="FormSettings_autoResourcing" type="java.lang.Integer" value="0"/>
    <AuxValue name="FormSettings_autoSetComponentName" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_generateFQN" type="java.lang.Boolean" value="true"/>
    <AuxValue name="FormSettings_generateMnemonicsCode" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_i18nAutoMode" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_layoutCodeTarget" type="java.lang.Integer" value="1"/>
    <AuxValue name="FormSettings_listenerGenerationStyle" type="java.lang.Integer" value="0"/>
    <AuxValue name="FormSettings_variablesLocal" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_variablesModifier" type="java.lang.Integer" value="2"/>
  </AuxValues>

  <Layout>
    <DimensionLayout dim="0">
      <Group type="103" groupAlignment="0" attributes="0">
          <Group type="102" attributes="0">
              <EmptySpace max="-2" attributes="0"/>
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <Component id="jLabel1" min="-2" pref="99" max="-2" attributes="0"/>
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jButton1" min="-2" max="-2" attributes="0"/>
                      <EmptySpace type="separate" max="-2" attributes="0"/>
                      <Component id="jButton2" min="-2" max="-2" attributes="0"/>
                      <EmptySpace min="-2" pref="33" max="-2" attributes="0"/>
                      <Component id="jButton3" min="-2" max="-2" attributes="0"/>
                      <EmptySpace min="0" pref="0" max="32767" attributes="0"/>
                  </Group>
                  <Component id="jTabbedPane2" alignment="1" max="32767" attributes="0"/>
              </Group>
              <EmptySpace max="-2" attributes="0"/>
          </Group>
      </Group>
    </DimensionLayout>
    <DimensionLayout dim="1">
      <Group type="103" groupAlignment="0" attributes="0">
          <Group type="102" alignment="0" attributes="0">
              <EmptySpace max="-2" attributes="0"/>
              <Group type="103" groupAlignment="3" attributes="0">
                  <Component id="jLabel1" alignment="3" min="-2" pref="24" max="-2" attributes="0"/>
                  <Component id="jButton1" alignment="3" min="-2" max="-2" attributes="0"/>
                  <Component id="jButton2" alignment="3" min="-2" max="-2" attributes="0"/>
                  <Component id="jButton3" alignment="3" min="-2" max="-2" attributes="0"/>
              </Group>
              <EmptySpace type="unrelated" max="-2" attributes="0"/>
              <Component id="jTabbedPane2" pref="484" max="32767" attributes="0"/>
              <EmptySpace min="-2" pref="18" max="-2" attributes="0"/>
          </Group>
      </Group>
    </DimensionLayout>
  </Layout>
  <SubComponents>
    <Component class="javax.swing.JLabel" name="jLabel1">
      <Properties>
        <Property name="text" type="java.lang.String" value="CourseWare "/>
      </Properties>
    </Component>
    <Container class="javax.swing.JTabbedPane" name="jTabbedPane2">

      <Layout class="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout"/>
      <SubComponents>
        <Container class="javax.swing.JPanel" name="jPanel2">
          <Constraints>
            <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout" value="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout$JTabbedPaneConstraintsDescription">
              <JTabbedPaneConstraints tabName="Basic Syntax">
                <Property name="tabTitle" type="java.lang.String" value="Basic Syntax"/>
              </JTabbedPaneConstraints>
            </Constraint>
          </Constraints>

          <Layout>
            <DimensionLayout dim="0">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane3" pref="1049" max="32767" attributes="0"/>
                      <EmptySpace min="-2" pref="39" max="-2" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
            <DimensionLayout dim="1">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Component id="jScrollPane3" alignment="1" pref="456" max="32767" attributes="0"/>
              </Group>
            </DimensionLayout>
          </Layout>
          <SubComponents>
            <Container class="javax.swing.JScrollPane" name="jScrollPane3">
              <AuxValues>
                <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
              </AuxValues>

              <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
              <SubComponents>
                <Component class="javax.swing.JTextArea" name="jTextArea3">
                  <Properties>
                    <Property name="columns" type="int" value="20"/>
                    <Property name="rows" type="int" value="5"/>
                    <Property name="text" type="java.lang.String" value="When we consider a Java program it can be defined as a collection of objects that communicate via invoking each other&apos;s methods. Let us now briefly look into what do class, object, methods and instance variables mean.&#xa;&#xa;Object - Objects have states and behaviours. Example: A dog has states - colour, name, breed as well as behaviours -wagging, barking, eating. An object is an instance of a class.&#xa;&#xa;Class - A class can be defined as a template/ blue print that describes the behaviours/states that object of its type support.&#xa;&#xa;Methods - A method is basically a behaviour. A class can contain many methods. It is in methods where the logics are written, data is manipulated and all the actions are executed.&#xa;&#xa;Instance Variables - Each object has its unique set of instance variables. An object&apos;s state is created by the values assigned to these instance variables.&#xa;&#xa;First Java Program:&#xa;Let us look at a simple code that would print the words Hello World.&#xa;&#xa;public class MyFirstJavaProgram {&#xa;&#xa;   /* This is my first java program.  &#xa;    * This will print &apos;Hello World&apos; as the output&#xa;    */&#xa;&#x9;&#xa;    public static void main(String []args) {&#xa;       System.out.println(&quot;Hello World&quot;); // prints Hello World&#xa;    }&#xa;} &#xa;Let&apos;s look at how to save the file, compile and run the program. Please follow the steps given below:&#xa;&#xa;Open notepad and add the code as above.&#xa;&#xa;Save the file as: MyFirstJavaProgram.java.&#xa;&#xa;Open a command prompt window and go to the directory where you saved the class. Assume it&apos;s C:\u005c.&#xa;&#xa;Type &apos; javac MyFirstJavaProgram.java&apos; and press enter to compile your code. If there are no errors in your code, the command prompt will take you to the next line (Assumption : The path variable is set).&#xa;&#xa;Now, type &apos; java MyFirstJavaProgram &apos; to run your program.&#xa;&#xa;You will be able to see &apos; Hello World &apos; printed on the window.&#xa;&#xa;C:\u005c&gt; javac MyFirstJavaProgram.java&#xa;C:\u005c&gt; java MyFirstJavaProgram &#xa;Hello World&#xa;Basic Syntax:&#xa;About Java programs, it is very important to keep in mind the following points.&#xa;&#xa;Case Sensitivity - Java is case sensitive, which means identifier Hello and hello would have different meaning in Java.&#xa;&#xa;Class Names - For all class names the first letter should be in Upper Case. &#xa;&#xa;If several words are used to form a name of the class, each inner word&apos;s first letter should be in Upper Case.&#xa;&#xa;Example class MyFirstJavaClass&#xa;&#xa;Method Names - All method names should start with a Lower Case letter. &#xa;&#xa;If several words are used to form the name of the method, then each inner word&apos;s first letter should be in Upper Case.&#xa;&#xa;Example public void myMethodName()&#xa;&#xa;Program File Name - Name of the program file should exactly match the class name. &#xa;&#xa;When saving the file, you should save it using the class name (Remember Java is case sensitive) and append &apos;.java&apos; to the end of the name (if the file name and the class name do not match your program will not compile).&#xa;&#xa;Example: Assume &apos;MyFirstJavaProgram&apos; is the class name. Then the file should be saved as &apos;MyFirstJavaProgram.java&apos;&#xa;&#xa;public static void main(String args[]) - Java program processing starts from the main() method which is a mandatory part of every Java program.&#xa;&#xa;Java Identifiers:&#xa;All Java components require names. Names used for classes, variables and methods are called identifiers.&#xa;&#xa;In Java, there are several points to remember about identifiers. They are as follows:&#xa;&#xa;All identifiers should begin with a letter (A to Z or a to z), currency character ($) or an underscore (_).&#xa;&#xa;After the first character identifiers can have any combination of characters.&#xa;&#xa;A key word cannot be used as an identifier.&#xa;&#xa;Most importantly identifiers are case sensitive.&#xa;&#xa;Examples of legal identifiers: age, $salary, _value, __1_value&#xa;&#xa;Examples of illegal identifiers: 123abc, -salary&#xa;&#xa;Java Modifiers:&#xa;Like other languages, it is possible to modify classes, methods, etc., by using modifiers. There are two categories of modifiers:&#xa;&#xa;Access Modifiers: default, public , protected, private&#xa;&#xa;Non-access Modifiers: final, abstract, strictfp&#xa;&#xa;We will be looking into more details about modifiers in the next section.&#xa;&#xa;Java Variables:&#xa;We would see following type of variables in Java:&#xa;&#xa;Local Variables&#xa;Class Variables (Static Variables)&#xa;Instance Variables (Non-static variables)&#xa;Java Arrays:&#xa;Arrays are objects that store multiple variables of the same type. However, an array itself is an object on the heap. We will look into how to declare, construct and initialize in the upcoming chapters.&#xa;&#xa;Java Enums:&#xa;Enums were introduced in java 5.0. Enums restrict a variable to have one of only a few predefined values. The values in this enumerated list are called enums.&#xa;&#xa;With the use of enums it is possible to reduce the number of bugs in your code.&#xa;&#xa;For example, if we consider an application for a fresh juice shop, it would be possible to restrict the glass size to small, medium and large. This would make sure that it would not allow anyone to order any size other than the small, medium or large.&#xa;&#xa;Example:&#xa;class FreshJuice {&#xa;&#xa;   enum FreshJuiceSize{ SMALL, MEDIUM, LARGE }&#xa;   FreshJuiceSize size;&#xa;}&#xa;&#xa;public class FreshJuiceTest {&#xa;&#xa;   public static void main(String args[]){&#xa;      FreshJuice juice = new FreshJuice();&#xa;      juice.size = FreshJuice.FreshJuiceSize.MEDIUM ;&#xa;      System.out.println(&quot;Size: &quot; + juice.size);&#xa;   }&#xa;}&#xa;Above example will produce the following result:&#xa;&#xa;Size: MEDIUM&#xa;Note: enums can be declared as their own or inside a class. Methods, variables, constructors can be defined inside enums as well.&#xa;&#xa;Java Keywords:&#xa;The following list shows the reserved words in Java. These reserved words may not be used as constant or variable or any other identifier names.&#xa;&#xa;abstract&#x9;assert&#x9;boolean&#x9;break&#xa;byte&#x9;case&#x9;catch&#x9;char&#xa;class&#x9;const&#x9;continue&#x9;default&#xa;do&#x9;double&#x9;else&#x9;enum&#xa;extends&#x9;final&#x9;finally&#x9;float&#xa;for&#x9;goto&#x9;if&#x9;implements&#xa;import&#x9;instanceof&#x9;int&#x9;interface&#xa;long&#x9;native&#x9;new&#x9;package&#xa;private&#x9;protected&#x9;public&#x9;return&#xa;short&#x9;static&#x9;strictfp&#x9;super&#xa;switch&#x9;synchronized&#x9;this&#x9;throw&#xa;throws&#x9;transient&#x9;try&#x9;void&#xa;volatile&#x9;while&#x9;&#x9;&#xa;Comments in Java&#xa;Java supports single-line and multi-line comments very similar to c and c++. All characters available inside any comment are ignored by Java compiler.&#xa;&#xa;public class MyFirstJavaProgram{&#xa;&#xa;   /* This is my first java program.&#xa;    * This will print &apos;Hello World&apos; as the output&#xa;    * This is an example of multi-line comments.&#xa;    */&#xa;&#xa;    public static void main(String []args){&#xa;       // This is an example of single line comment&#xa;       /* This is also an example of single line comment. */&#xa;       System.out.println(&quot;Hello World&quot;); &#xa;    }&#xa;} &#xa;Using Blank Lines:&#xa;A line containing only white space, possibly with a comment, is known as a blank line, and Java totally ignores it.&#xa;&#xa;Inheritance:&#xa;In Java, classes can be derived from classes. Basically if you need to create a new class and here is already a class that has some of the code you require, then it is possible to derive your new class from the already existing code.&#xa;&#xa;This concept allows you to reuse the fields and methods of the existing class without having to rewrite the code in a new class. In this scenario the existing class is called the superclass and the derived class is called the subclass.&#xa;&#xa;Interfaces:&#xa;In Java language, an interface can be defined as a contract between objects on how to communicate with each other. Interfaces play a vital role when it comes to the concept of inheritance.&#xa;&#xa;An interface defines the methods, a deriving class(subclass) should use. But the implementation of the methods is totally up to the subclass." containsInvalidXMLChars="true"/>
                  </Properties>
                </Component>
              </SubComponents>
            </Container>
          </SubComponents>
        </Container>
        <Container class="javax.swing.JPanel" name="jPanel3">
          <Constraints>
            <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout" value="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout$JTabbedPaneConstraintsDescription">
              <JTabbedPaneConstraints tabName="Datatypes &amp; Variables">
                <Property name="tabTitle" type="java.lang.String" value="Datatypes &amp; Variables"/>
              </JTabbedPaneConstraints>
            </Constraint>
          </Constraints>

          <Layout>
            <DimensionLayout dim="0">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane2" pref="1078" max="32767" attributes="0"/>
                      <EmptySpace max="-2" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
            <DimensionLayout dim="1">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <Component id="jScrollPane2" pref="445" max="32767" attributes="0"/>
                      <EmptySpace max="-2" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
          </Layout>
          <SubComponents>
            <Container class="javax.swing.JScrollPane" name="jScrollPane2">
              <AuxValues>
                <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
              </AuxValues>

              <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
              <SubComponents>
                <Component class="javax.swing.JTextArea" name="jTextArea2">
                  <Properties>
                    <Property name="columns" type="int" value="20"/>
                    <Property name="rows" type="int" value="5"/>
                    <Property name="text" type="java.lang.String" value="A variable provides us with named storage that our programs can manipulate. Each variable in Java has a specific type, which determines the size and layout of the variable&apos;s memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.&#xa;&#xa;You must declare all variables before they can be used. The basic form of a variable declaration is shown here:&#xa;&#xa;data type variable [ = value][, variable [= value] ...] ;&#xa;Here data type is one of Java&apos;s datatypes and variable is the name of the variable. To declare more than one variable of the specified type, you can use a comma-separated list.&#xa;&#xa;Following are valid examples of variable declaration and initialization in Java:&#xa;&#xa;int a, b, c;         // Declares three ints, a, b, and c.&#xa;int a = 10, b = 10;  // Example of initialization&#xa;byte B = 22;         // initializes a byte type variable B.&#xa;double pi = 3.14159; // declares and assigns a value of PI.&#xa;char a = &apos;a&apos;;        // the char variable a iis initialized with value &apos;a&apos;&#xa;This chapter will explain various variable types available in Java Language. There are three kinds of variables in Java:&#xa;&#xa;Local variables&#xa;&#xa;Instance variables&#xa;&#xa;Class/static variables&#xa;&#xa;Local variables:&#xa;Local variables are declared in methods, constructors, or blocks.&#xa;&#xa;Local variables are created when the method, constructor or block is entered and the variable will be destroyed once it exits the method, constructor or block.&#xa;&#xa;Access modifiers cannot be used for local variables.&#xa;&#xa;Local variables are visible only within the declared method, constructor or block.&#xa;&#xa;Local variables are implemented at stack level internally.&#xa;&#xa;There is no default value for local variables so local variables should be declared and an initial value should be assigned before the first use.&#xa;&#xa;Example:&#xa;Here, age is a local variable. This is defined inside pupAge() method and its scope is limited to this method only.&#xa;&#xa;public class Test{ &#xa;   public void pupAge(){&#xa;      int age = 0;&#xa;      age = age + 7;&#xa;      System.out.println(&quot;Puppy age is : &quot; + age);&#xa;   }&#xa;   &#xa;   public static void main(String args[]){&#xa;      Test test = new Test();&#xa;      test.pupAge();&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;Puppy age is: 7&#xa;Example:&#xa;Following example uses age without initializing it, so it would give an error at the time of compilation.&#xa;&#xa;public class Test{ &#xa;   public void pupAge(){&#xa;      int age;&#xa;      age = age + 7;&#xa;      System.out.println(&quot;Puppy age is : &quot; + age);&#xa;   }&#xa;   &#xa;   public static void main(String args[]){&#xa;      Test test = new Test();&#xa;      test.pupAge();&#xa;   }&#xa;}&#xa;This would produce the following error while compiling it:&#xa;&#xa;Test.java:4:variable number might not have been initialized&#xa;age = age + 7;&#xa;         ^&#xa;1 error&#xa;Instance variables:&#xa;Instance variables are declared in a class, but outside a method, constructor or any block.&#xa;&#xa;When a space is allocated for an object in the heap, a slot for each instance variable value is created.&#xa;&#xa;Instance variables are created when an object is created with the use of the keyword &apos;new&apos; and destroyed when the object is destroyed.&#xa;&#xa;Instance variables hold values that must be referenced by more than one method, constructor or block, or essential parts of an object&apos;s state that must be present throughout the class.&#xa;&#xa;Instance variables can be declared in class level before or after use.&#xa;&#xa;Access modifiers can be given for instance variables.&#xa;&#xa;The instance variables are visible for all methods, constructors and block in the class. Normally, it is recommended to make these variables private (access level). However visibility for subclasses can be given for these variables with the use of access modifiers.&#xa;&#xa;Instance variables have default values. For numbers the default value is 0, for Booleans it is false and for object references it is null. Values can be assigned during the declaration or within the constructor.&#xa;&#xa;Instance variables can be accessed directly by calling the variable name inside the class. However within static methods and different class ( when instance variables are given accessibility) should be called using the fully qualified name . ObjectReference.VariableName.&#xa;&#xa;Example:&#xa;import java.io.*;&#xa;&#xa;public class Employee{&#xa;   // this instance variable is visible for any child class.&#xa;   public String name;&#xa;   &#xa;   // salary  variable is visible in Employee class only.&#xa;   private double salary;&#xa;   &#xa;   // The name variable is assigned in the constructor. &#xa;   public Employee (String empName){&#xa;      name = empName;&#xa;   }&#xa;&#xa;   // The salary variable is assigned a value.&#xa;   public void setSalary(double empSal){&#xa;      salary = empSal;&#xa;   }&#xa;   &#xa;   // This method prints the employee details.&#xa;   public void printEmp(){&#xa;      System.out.println(&quot;name  : &quot; + name );&#xa;      System.out.println(&quot;salary :&quot; + salary);&#xa;   }&#xa;&#xa;   public static void main(String args[]){&#xa;      Employee empOne = new Employee(&quot;Ransika&quot;);&#xa;      empOne.setSalary(1000);&#xa;      empOne.printEmp();&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;name  : Ransika&#xa;salary :1000.0&#xa;Class/static variables:&#xa;Class variables also known as static variables are declared with the static keyword in a class, but outside a method, constructor or a block.&#xa;&#xa;There would only be one copy of each class variable per class, regardless of how many objects are created from it.&#xa;&#xa;Static variables are rarely used other than being declared as constants. Constants are variables that are declared as public/private, final and static. Constant variables never change from their initial value.&#xa;&#xa;Static variables are stored in static memory. It is rare to use static variables other than declared final and used as either public or private constants.&#xa;&#xa;Static variables are created when the program starts and destroyed when the program stops.&#xa;&#xa;Visibility is similar to instance variables. However, most static variables are declared public since they must be available for users of the class.&#xa;&#xa;Default values are same as instance variables. For numbers, the default value is 0; for Booleans, it is false; and for object references, it is null. Values can be assigned during the declaration or within the constructor. Additionally values can be assigned in special static initializer blocks.&#xa;&#xa;Static variables can be accessed by calling with the class name ClassName.VariableName.&#xa;&#xa;When declaring class variables as public static final, then variables names (constants) are all in upper case. If the static variables are not public and final the naming syntax is the same as instance and local variables.&#xa;&#xa;Example:&#xa;import java.io.*;&#xa;&#xa;public class Employee{&#xa;   // salary  variable is a private static variable&#xa;   private static double salary;&#xa;&#xa;   // DEPARTMENT is a constant&#xa;   public static final String DEPARTMENT = &quot;Development &quot;;&#xa;&#xa;   public static void main(String args[]){&#xa;      salary = 1000;&#xa;      System.out.println(DEPARTMENT + &quot;average salary:&quot; + salary);&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;Development average salary:1000&#xa;Note: If the variables are access from an outside class the constant should be accessed as Employee.DEPARTMENT"/>
                  </Properties>
                </Component>
              </SubComponents>
            </Container>
          </SubComponents>
        </Container>
        <Container class="javax.swing.JPanel" name="jPanel4">
          <Constraints>
            <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout" value="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout$JTabbedPaneConstraintsDescription">
              <JTabbedPaneConstraints tabName="Loops &amp; Decision Making">
                <Property name="tabTitle" type="java.lang.String" value="Loops &amp; Decision Making"/>
              </JTabbedPaneConstraints>
            </Constraint>
          </Constraints>

          <Layout>
            <DimensionLayout dim="0">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane4" pref="1078" max="32767" attributes="0"/>
                      <EmptySpace max="-2" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
            <DimensionLayout dim="1">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane4" pref="434" max="32767" attributes="0"/>
                      <EmptySpace max="-2" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
          </Layout>
          <SubComponents>
            <Container class="javax.swing.JScrollPane" name="jScrollPane4">
              <AuxValues>
                <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
              </AuxValues>

              <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
              <SubComponents>
                <Component class="javax.swing.JTextArea" name="jTextArea4">
                  <Properties>
                    <Property name="columns" type="int" value="20"/>
                    <Property name="rows" type="int" value="5"/>
                    <Property name="text" type="java.lang.String" value="There may be a situation when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.&#xa;&#xa;Programming languages provide various control structures that allow for more complicated execution paths.&#xa;&#xa;A loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages:&#xa;&#xa;Java Tutorial&#xa;Java programming language provides the following types of loop to handle looping requirements. Click the following links to check their detail.&#xa;&#xa;Loop Type&#x9;Description&#xa;while loop&#xa;&#xa;Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.&#xa;for loop&#xa;&#xa;Execute a sequence of statements multiple times and abbreviates the code that manages the loop variable.&#xa;do...while loop&#xa;&#xa;Like a while statement, except that it tests the condition at the end of the loop body&#xa;Loop Control Statements:&#xa;Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.&#xa;&#xa;Java supports the following control statements. Click the following links to check their detail.&#xa;&#xa;Control Statement&#x9;Description&#xa;break statement&#xa;&#xa;Terminates the loop or switch statement and transfers execution to the statement immediately following the loop or switch.&#xa;continue statement&#xa;&#xa;Causes the loop to skip the remainder of its body and immediately retest its condition prior to reiterating.&#xa;Enhanced for loop in Java:&#xa;As of Java 5, the enhanced for loop was introduced. This is mainly used to traverse collection of elements including arrays.&#xa;&#xa;Syntax:&#xa;The syntax of enhanced for loop is:&#xa;&#xa;for(declaration : expression)&#xa;{&#xa;   //Statements&#xa;}&#xa;Declaration: The newly declared block variable, which is of a type compatible with the elements of the array you are accessing. The variable will be available within the for block and its value would be the same as the current array element.&#xa;&#xa;Expression: This evaluates to the array you need to loop through. The expression can be an array variable or method call that returns an array.&#xa;&#xa;Example:&#xa;public class Test {&#xa;&#xa;   public static void main(String args[]){&#xa;      int [] numbers = {10, 20, 30, 40, 50};&#xa;&#xa;      for(int x : numbers ){&#xa;         System.out.print( x );&#xa;         System.out.print(&quot;,&quot;);&#xa;      }&#xa;      System.out.print(&quot;\u005cn&quot;);&#xa;      String [] names ={&quot;James&quot;, &quot;Larry&quot;, &quot;Tom&quot;, &quot;Lacy&quot;};&#xa;      for( String name : names ) {&#xa;         System.out.print( name );&#xa;         System.out.print(&quot;,&quot;);&#xa;      }&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;10,20,30,40,50,&#xa;James,Larry,Tom,Lacy,&#xa;Decision making structures have one or more conditions to be evaluated or tested by the program, along with a statement or statements that are to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.&#xa;&#xa;Following is the general form of a typical decision making structure found in most of the programming languages:&#xa;&#xa;Java Tutorial&#xa;Java programming language provides following types of decision making statements. Click the following links to check their detail.&#xa;&#xa;Statement&#x9;Description&#xa;if statement&#xa;&#xa;An if statement consists of a boolean expression followed by one or more statements.&#xa;if...else statement&#xa;&#xa;An if statement can be followed by an optional else statement, which executes when the boolean expression is false.&#xa;nested if statements&#xa;&#xa;You can use one if or else if statement inside another if or else if statement(s).&#xa;switch statement&#xa;&#xa;A switch statement allows a variable to be tested for equality against a list of values.&#xa;The ? : Operator:&#xa;We have covered conditional operator ? : in previous chapter which can be used to replace if...else statements. It has the following general form:&#xa;&#xa;Exp1 ? Exp2 : Exp3;&#xa;Where Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.&#xa;&#xa;To determine the value of whole expression, initially exp1 is evaluated&#xa;&#xa;If the value of exp1 is true, then the value of Exp2 will be the value of the whole expression.&#xa;If the value of exp1 is false, then Exp3 is evaluated and its value becomes the value of the entire expression." containsInvalidXMLChars="true"/>
                  </Properties>
                </Component>
              </SubComponents>
            </Container>
          </SubComponents>
        </Container>
        <Container class="javax.swing.JPanel" name="jPanel5">
          <Constraints>
            <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout" value="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout$JTabbedPaneConstraintsDescription">
              <JTabbedPaneConstraints tabName="Arrays and Strings">
                <Property name="tabTitle" type="java.lang.String" value="Arrays and Strings"/>
              </JTabbedPaneConstraints>
            </Constraint>
          </Constraints>

          <Layout>
            <DimensionLayout dim="0">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane5" pref="1078" max="32767" attributes="0"/>
                      <EmptySpace max="-2" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
            <DimensionLayout dim="1">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane5" pref="445" max="32767" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
          </Layout>
          <SubComponents>
            <Container class="javax.swing.JScrollPane" name="jScrollPane5">
              <AuxValues>
                <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
              </AuxValues>

              <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
              <SubComponents>
                <Component class="javax.swing.JTextArea" name="jTextArea5">
                  <Properties>
                    <Property name="columns" type="int" value="20"/>
                    <Property name="rows" type="int" value="5"/>
                    <Property name="text" type="java.lang.String" value="Java provides a data structure, the array, which stores a fixed-size sequential collection of elements of the same type. An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.&#xa;&#xa;Instead of declaring individual variables, such as number0, number1, ..., and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and ..., numbers[99] to represent individual variables.&#xa;&#xa;This tutorial introduces how to declare array variables, create arrays, and process arrays using indexed variables.&#xa;&#xa;Declaring Array Variables:&#xa;To use an array in a program, you must declare a variable to reference the array, and you must specify the type of array the variable can reference. Here is the syntax for declaring an array variable:&#xa;&#xa;dataType[] arrayRefVar;   // preferred way.&#xa;&#xa;or&#xa;&#xa;dataType arrayRefVar[];  //  works but not preferred way.&#xa;Note: The style dataType[] arrayRefVar is preferred. The style dataType arrayRefVar[] comes from the C/C++ language and was adopted in Java to accommodate C/C++ programmers.&#xa;&#xa;Example:&#xa;The following code snippets are examples of this syntax:&#xa;&#xa;double[] myList;         // preferred way.&#xa;&#xa;or&#xa;&#xa;double myList[];         //  works but not preferred way.&#xa;Creating Arrays:&#xa;You can create an array by using the new operator with the following syntax:&#xa;&#xa;arrayRefVar = new dataType[arraySize];&#xa;The above statement does two things:&#xa;&#xa;It creates an array using new dataType[arraySize];&#xa;&#xa;It assigns the reference of the newly created array to the variable arrayRefVar.&#xa;&#xa;Declaring an array variable, creating an array, and assigning the reference of the array to the variable can be combined in one statement, as shown below:&#xa;&#xa;dataType[] arrayRefVar = new dataType[arraySize];&#xa;Alternatively you can create arrays as follows:&#xa;&#xa;dataType[] arrayRefVar = {value0, value1, ..., valuek};&#xa;The array elements are accessed through the index. Array indices are 0-based; that is, they start from 0 to arrayRefVar.length-1.&#xa;&#xa;Example:&#xa;Following statement declares an array variable, myList, creates an array of 10 elements of double type and assigns its reference to myList:&#xa;&#xa;double[] myList = new double[10];&#xa;Following picture represents array myList. Here, myList holds ten double values and the indices are from 0 to 9.&#xa;&#xa;Java Array&#xa;Processing Arrays:&#xa;When processing array elements, we often use either for loop or foreach loop because all of the elements in an array are of the same type and the size of the array is known.&#xa;&#xa;Example:&#xa;Here is a complete example of showing how to create, initialize and process arrays:&#xa;&#xa;public class TestArray {&#xa;&#xa;   public static void main(String[] args) {&#xa;      double[] myList = {1.9, 2.9, 3.4, 3.5};&#xa;&#xa;      // Print all the array elements&#xa;      for (int i = 0; i &lt; myList.length; i++) {&#xa;         System.out.println(myList[i] + &quot; &quot;);&#xa;      }&#xa;      // Summing all elements&#xa;      double total = 0;&#xa;      for (int i = 0; i &lt; myList.length; i++) {&#xa;         total += myList[i];&#xa;      }&#xa;      System.out.println(&quot;Total is &quot; + total);&#xa;      // Finding the largest element&#xa;      double max = myList[0];&#xa;      for (int i = 1; i &lt; myList.length; i++) {&#xa;         if (myList[i] &gt; max) max = myList[i];&#xa;      }&#xa;      System.out.println(&quot;Max is &quot; + max);&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;1.9&#xa;2.9&#xa;3.4&#xa;3.5&#xa;Total is 11.7&#xa;ax is 3.5&#xa;The foreach Loops:&#xa;JDK 1.5 introduced a new for loop known as foreach loop or enhanced for loop, which enables you to traverse the complete array sequentially without using an index variable.&#xa;&#xa;Example:&#xa;The following code displays all the elements in the array myList:&#xa;&#xa;public class TestArray {&#xa;&#xa;   public static void main(String[] args) {&#xa;      double[] myList = {1.9, 2.9, 3.4, 3.5};&#xa;&#xa;      // Print all the array elements&#xa;      for (double element: myList) {&#xa;         System.out.println(element);&#xa;      }&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;1.9&#xa;2.9&#xa;3.4&#xa;3.5&#xa;Passing Arrays to Methods:&#xa;Just as you can pass primitive type values to methods, you can also pass arrays to methods. For example, the following method displays the elements in an int array:&#xa;&#xa;public static void printArray(int[] array) {&#xa;  for (int i = 0; i &lt; array.length; i++) {&#xa;    System.out.print(array[i] + &quot; &quot;);&#xa;  }&#xa;}&#xa;You can invoke it by passing an array. For example, the following statement invokes the printArray method to display 3, 1, 2, 6, 4, and 2:&#xa;&#xa;printArray(new int[]{3, 1, 2, 6, 4, 2});&#xa;Returning an Array from a Method:&#xa;A method may also return an array. For example, the method shown below returns an array that is the reversal of another array:&#xa;&#xa;public static int[] reverse(int[] list) {&#xa;  int[] result = new int[list.length];&#xa;&#xa;  for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) {&#xa;    result[j] = list[i];&#xa;  }&#xa;  return result;&#xa;}&#xa;The Arrays Class:&#xa;The java.util.Arrays class contains various static methods for sorting and searching arrays, comparing arrays, and filling array elements. These methods are overloaded for all primitive types.&#xa;&#xa;SN&#x9;Methods with Description&#xa;1&#x9;public static int binarySearch(Object[] a, Object key)&#xa;Searches the specified array of Object ( Byte, Int , double, etc.) for the specified value using the binary search algorithm. The array must be sorted prior to making this call. This returns index of the search key, if it is contained in the list; otherwise, (-(insertion point + 1).&#xa;&#xa;2&#x9;public static boolean equals(long[] a, long[] a2)&#xa;Returns true if the two specified arrays of longs are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. This returns true if the two arrays are equal. Same method could be used by all other primitive data types (Byte, short, Int, etc.)&#xa;&#xa;3&#x9;public static void fill(int[] a, int val)&#xa;Assigns the specified int value to each element of the specified array of ints. Same method could be used by all other primitive data types (Byte, short, Int etc.)&#xa;&#xa;4&#x9;public static void sort(Object[] a)&#xa;Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. Same method could be used by all other primitive data types ( Byte, short, Int, etc.)"/>
                  </Properties>
                </Component>
              </SubComponents>
            </Container>
          </SubComponents>
        </Container>
        <Container class="javax.swing.JPanel" name="jPanel6">
          <Constraints>
            <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout" value="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout$JTabbedPaneConstraintsDescription">
              <JTabbedPaneConstraints tabName="Methods">
                <Property name="tabTitle" type="java.lang.String" value="Methods"/>
              </JTabbedPaneConstraints>
            </Constraint>
          </Constraints>

          <Layout>
            <DimensionLayout dim="0">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane6" pref="1088" max="32767" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
            <DimensionLayout dim="1">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane6" pref="445" max="32767" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
          </Layout>
          <SubComponents>
            <Container class="javax.swing.JScrollPane" name="jScrollPane6">
              <AuxValues>
                <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
              </AuxValues>

              <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
              <SubComponents>
                <Component class="javax.swing.JTextArea" name="jTextArea6">
                  <Properties>
                    <Property name="columns" type="int" value="20"/>
                    <Property name="rows" type="int" value="5"/>
                    <Property name="text" type="java.lang.String" value="A Java method is a collection of statements that are grouped together to perform an operation. When you call the System.out.println() method, for example, the system actually executes several statements in order to display a message on the console.&#xa;&#xa;Now you will learn how to create your own methods with or without return values, invoke a method with or without parameters, and apply method abstraction in the program design.&#xa;&#xa;Creating Method:&#xa;Considering the following example to explain the syntax of a method:&#xa;&#xa;public static int methodName(int a, int b) {&#xa;  // body&#xa;}&#xa;Here,&#xa;&#xa;public static : modifier.&#xa;&#xa;int: return type&#xa;&#xa;methodName: name of the method&#xa;&#xa;a, b: formal parameters&#xa;&#xa;int a, int b: list of parameters&#xa;&#xa;Method definition consists of a method header and a method body. The same is shown below:&#xa;&#xa;modifier returnType nameOfMethod (Parameter List) {&#xa; // method body&#xa;}&#xa;The syntax shown above includes:&#xa;&#xa;modifier: It defines the access type of the method and it is optional to use.&#xa;&#xa;returnType: Method may return a value.&#xa;&#xa;nameOfMethod: This is the method name. The method signature consists of the method name and the parameter list.&#xa;&#xa;Parameter List: The list of parameters, it is the type, order, and number of parameters of a method. These are optional, method may contain zero parameters.&#xa;&#xa;method body: The method body defines what the method does with statements.&#xa;&#xa;Example:&#xa;Here is the source code of the above defined method called max(). This method takes two parameters num1 and num2 and returns the maximum between the two:&#xa;&#xa;/** the snippet returns the minimum between two numbers */&#xa;public static int minFunction(int n1, int n2) {&#xa;   int min;&#xa;   if (n1 &gt; n2)&#xa;      min = n2;&#xa;   else&#xa;      min = n1;&#xa;&#xa;   return min; &#xa;}&#xa;Method Calling:&#xa;For using a method, it should be called. There are two ways in which a method is called i.e. method returns a value or returning nothing (no return value).&#xa;&#xa;The process of method calling is simple. When a program invokes a method, the program control gets transferred to the called method. This called method then returns control to the caller in two conditions, when:&#xa;&#xa;return statement is executed.&#xa;&#xa;reaches the method ending closing brace.&#xa;&#xa;The methods returning void is considered as call to a statement. Lets consider an example:&#xa;&#xa;System.out.println(&quot;This is tutorialspoint.com!&quot;);&#xa;The method returning value can be understood by the following example:&#xa;&#xa;int result = sum(6, 9);&#xa;Example:&#xa;Following is the example to demonstrate how to define a method and how to call it:&#xa;&#xa;public class ExampleMinNumber{&#xa;   &#xa;   public static void main(String[] args) {&#xa;      int a = 11;&#xa;      int b = 6;&#xa;      int c = minFunction(a, b);&#xa;      System.out.println(&quot;Minimum Value = &quot; + c);&#xa;   }&#xa;&#xa;   /** returns the minimum of two numbers */&#xa;   public static int minFunction(int n1, int n2) {&#xa;      int min;&#xa;      if (n1 &gt; n2)&#xa;         min = n2;&#xa;      else&#xa;         min = n1;&#xa;&#xa;      return min; &#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;inimum value = 6&#xa;The void Keyword:&#xa;The void keyword allows us to create methods which do not return a value. Here, in the following example we&apos;re considering a void method methodRankPoints. This method is a void method which does not return any value. Call to a void method must be a statement i.e. methodRankPoints(255.7);. It is a Java statement which ends with a semicolon as shown below.&#xa;&#xa;Example:&#xa;public class ExampleVoid {&#xa;&#xa;   public static void main(String[] args) {&#xa;      methodRankPoints(255.7);&#xa;   }&#xa;&#xa;   public static void methodRankPoints(double points) {&#xa;      if (points &gt;= 202.5) {&#xa;         System.out.println(&quot;Rank:A1&quot;);&#xa;      }&#xa;      else if (points &gt;= 122.4) {&#xa;         System.out.println(&quot;Rank:A2&quot;);&#xa;      }&#xa;      else {&#xa;         System.out.println(&quot;Rank:A3&quot;);&#xa;      }&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;Rank:A1&#xa;Passing Parameters by Value:&#xa;While working under calling process, arguments is to be passed. These should be in the same order as their respective parameters in the method specification. Parameters can be passed by value or by reference.&#xa;&#xa;Passing Parameters by Value means calling a method with a parameter. Through this the argument value is passed to the parameter.&#xa;&#xa;Example:&#xa;The following program shows an example of passing parameter by value. The values of the arguments remains the same even after the method invocation.&#xa;&#xa;public class swappingExample {&#xa;&#xa;   public static void main(String[] args) {&#xa;      int a = 30;&#xa;      int b = 45;&#xa;&#xa;      System.out.println(&quot;Before swapping, a = &quot; +&#xa;                          a + &quot; and b = &quot; + b);&#xa;&#xa;      // Invoke the swap method&#xa;      swapFunction(a, b);&#xa;      System.out.println(&quot;\u005cn**Now, Before and After swapping values will be same here**:&quot;);&#xa;      System.out.println(&quot;After swapping, a = &quot; +&#xa;                         a + &quot; and b is &quot; + b);&#xa;   }&#xa;&#xa;   public static void swapFunction(int a, int b) {&#xa;   &#xa;      System.out.println(&quot;Before swapping(Inside), a = &quot; + a&#xa;                           + &quot; b = &quot; + b);&#xa;      // Swap n1 with n2&#xa;      int c = a;&#xa;      a = b;&#xa;      b = c;&#xa;&#xa;      System.out.println(&quot;After swapping(Inside), a = &quot; + a&#xa;                           + &quot; b = &quot; + b);&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;Before swapping, a = 30 and b = 45&#xa;Before swapping(Inside), a = 30 b = 45&#xa;After swapping(Inside), a = 45 b = 30&#xa;&#xa;**Now, Before and After swapping values will be same here**:&#xa;After swapping, a = 30 and b is 45&#xa;Method Overloading:&#xa;When a class has two or more methods by same name but different parameters, it is known as method overloading. It is different from overriding. In overriding a method has same method name, type, number of parameters etc.&#xa;&#xa;Lets consider the example shown before for finding minimum numbers of integer type. If, lets say we want to find minimum number of double type. Then the concept of Overloading will be introduced to create two or more methods with the same name but different parameters.&#xa;&#xa;The below example explains the same:&#xa;&#xa;public class ExampleOverloading{&#xa;&#xa;   public static void main(String[] args) {&#xa;      int a = 11;&#xa;      int b = 6;&#xa;      double c = 7.3;&#xa;      double d = 9.4;&#xa;      int result1 = minFunction(a, b);&#xa;      // same function name with different parameters&#xa;      double result2 = minFunction(c, d);&#xa;      System.out.println(&quot;Minimum Value = &quot; + result1);&#xa;      System.out.println(&quot;Minimum Value = &quot; + result2);&#xa;   }&#xa;&#xa;  // for integer&#xa;   public static int minFunction(int n1, int n2) {&#xa;      int min;&#xa;      if (n1 &gt; n2)&#xa;         min = n2;&#xa;      else&#xa;         min = n1;&#xa;&#xa;      return min; &#xa;   }&#xa;   // for double&#xa;   public static double minFunction(double n1, double n2) {&#xa;     double min;&#xa;      if (n1 &gt; n2)&#xa;         min = n2;&#xa;      else&#xa;         min = n1;&#xa;&#xa;      return min; &#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;inimum Value = 6&#xa;inimum Value = 7.3&#xa;Overloading methods makes program readable. Here, two methods are given same name but with different parameters. The minimum number from integer and double types is the result.&#xa;&#xa;Using Command-Line Arguments:&#xa;Sometimes you will want to pass information into a program when you run it. This is accomplished by passing command-line arguments to main( ).&#xa;&#xa;A command-line argument is the information that directly follows the program&apos;s name on the command line when it is executed. To access the command-line arguments inside a Java program is quite easy.they are stored as strings in the String array passed to main( ).&#xa;&#xa;Example:&#xa;The following program displays all of the command-line arguments that it is called with:&#xa;&#xa;public class CommandLine {&#xa;&#xa;   public static void main(String args[]){ &#xa;      for(int i=0; i&lt;args.length; i++){&#xa;         System.out.println(&quot;args[&quot; + i + &quot;]: &quot; +&#xa;                                           args[i]);&#xa;      }&#xa;   }&#xa;}&#xa;Try executing this program as shown here:&#xa;&#xa;$java CommandLine this is a command line 200 -100&#xa;This would produce the following result:&#xa;&#xa;args[0]: this&#xa;args[1]: is&#xa;args[2]: a&#xa;args[3]: command&#xa;args[4]: line&#xa;args[5]: 200&#xa;args[6]: -100&#xa;The Constructors:&#xa;A constructor initializes an object when it is created. It has the same name as its class and is syntactically similar to a method. However, constructors have no explicit return type.&#xa;&#xa;Typically, you will use a constructor to give initial values to the instance variables defined by the class, or to perform any other startup procedures required to create a fully formed object.&#xa;&#xa;All classes have constructors, whether you define one or not, because Java automatically provides a default constructor that initializes all member variables to zero. However, once you define your own constructor, the default constructor is no longer used.&#xa;&#xa;Example:&#xa;Here is a simple example that uses a constructor without parameters:&#xa;&#xa;// A simple constructor.&#xa;class MyClass {&#xa;   int x;&#xa;   &#xa;   // Following is the constructor&#xa;   MyClass() {&#xa;      x = 10;&#xa;   }&#xa;}&#xa;You would call constructor to initialize objects as follows:&#xa;&#xa;public class ConsDemo {&#xa;&#xa;   public static void main(String args[]) {&#xa;      MyClass t1 = new MyClass();&#xa;      MyClass t2 = new MyClass();&#xa;      System.out.println(t1.x + &quot; &quot; + t2.x);&#xa;   }&#xa;}&#xa;parametarized constructor&#xa;Most often, you will need a constructor that accepts one or more parameters. Parameters are added to a constructor in the same way that they are added to a method, just declare them inside the parentheses after the constructor&apos;s name.&#xa;&#xa;Example:&#xa;Here is a simple example that uses a constructor with parameter:&#xa;&#xa;// A simple constructor.&#xa;class MyClass {&#xa;   int x;&#xa;   &#xa;   // Following is the constructor&#xa;   MyClass(int i ) {&#xa;      x = i;&#xa;   }&#xa;}&#xa;You would call constructor to initialize objects as follows:&#xa;&#xa;public class ConsDemo {&#xa;&#xa;   public static void main(String args[]) {&#xa;      MyClass t1 = new MyClass( 10 );&#xa;      MyClass t2 = new MyClass( 20 );&#xa;      System.out.println(t1.x + &quot; &quot; + t2.x);&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;10 20&#xa;The this keyword&#xa;this is a keyword in Java which is used as a reference to the object of the current class, with in an instance method or a constructor. Using this you can refer the members of a class such as constructors, variables and methods.&#xa;&#xa;NoteThe keyword this is used only within instance methods or constructors&#xa;&#xa;Java Tutorial&#xa; &#xa;&#xa;In general the keyword this is used to :&#xa;Differentiate the instance variables from local variables if they have same names, within a constructor or a method.&#xa;&#xa;class Student{&#xa;&#xa;   int age;   &#xa;   Student(int age){&#xa;   this.age=age;&#x9;&#xa;   }&#xa;&#xa;}&#xa;Call one type of constructor( parametrized constructor or default ) from other in a class. It is known as explicit constructor invocation .&#xa;&#xa;class Student{&#xa;&#xa;   int age&#xa;   Student(){&#xa;   this(20);&#xa;   }&#xa;   &#xa;   Student(int age){&#xa;   this.age=age;&#x9;&#xa;   }&#xa;&#xa;}&#xa;Example&#xa;Here is an example that uses this keyword to access the members of a class. Copy and paste the below given program in a file with name This_Example.java&#xa;&#xa;public class This_Example {&#xa;&#x9;&#xa;   //Instance variable num&#xa;   int num=10;&#xa;&#x9;&#xa;   This_Example(){&#xa;      System.out.println(&quot;This is an example program on keyword this &quot;);&#x9;&#xa;   }&#xa;&#xa;   This_Example(int num){&#xa;      //Invoking the default constructor&#xa;      this();&#xa;      &#xa;      //Assigning the local variable num to the instance variable num&#xa;      this.num=num;&#x9;   &#xa;   }&#xa;   &#xa;   public void greet(){&#xa;      System.out.println(&quot;Hi Welcome to Tutorialspoint&quot;);&#xa;   }&#xa;      &#xa;   public void print(){&#xa;      //Local variable num&#xa;      int num=20;&#xa;      &#xa;      //Printing the instance variable&#xa;      System.out.println(&quot;value of local variable num is : &quot;+num);&#xa;      &#xa;      //Printing the local variable&#xa;      System.out.println(&quot;value of instance variable num is : &quot;+this.num);&#xa;      &#xa;      //Invoking the greet method of a class&#xa;      this.greet();     &#xa;   }&#xa;   &#xa;   public static void main(String[] args){&#xa;      //Instantiating the class&#xa;      This_Example obj1=new This_Example();&#xa;      &#xa;      //Invoking the print method&#xa;      obj1.print();&#xa;&#x9;  &#xa;      //Passing a new value to the num variable through parametrized constructor&#xa;      This_Example obj2=new This_Example(30);&#xa;      &#xa;      //Invoking the print method again&#xa;      obj2.print(); &#xa;   }&#xa;&#xa;}&#xa;This would produce the following result:&#xa;This is an example program on keyword this &#xa;value of local variable num is : 20&#xa;value of instance variable num is : 10&#xa;Hi Welcome to Tutorialspoint&#xa;This is an example program on keyword this &#xa;value of local variable num is : 20&#xa;value of instance variable num is : 30&#xa;Hi Welcome to Tutorialspoint&#xa;Variable Arguments(var-args):&#xa;JDK 1.5 enables you to pass a variable number of arguments of the same type to a method. The parameter in the method is declared as follows:&#xa;&#xa;typeName... parameterName&#xa;In the method declaration, you specify the type followed by an ellipsis (...) Only one variable-length parameter may be specified in a method, and this parameter must be the last parameter. Any regular parameters must precede it.&#xa;&#xa;Example:&#xa;public class VarargsDemo {&#xa;&#xa;   public static void main(String args[]) {&#xa;      // Call method with variable args  &#xa;&#x9;  printMax(34, 3, 3, 2, 56.5);&#xa;      printMax(new double[]{1, 2, 3});&#xa;   }&#xa;&#xa;   public static void printMax( double... numbers) {&#xa;   if (numbers.length == 0) {&#xa;      System.out.println(&quot;No argument passed&quot;);&#xa;      return;&#xa;   }&#xa;&#xa;   double result = numbers[0];&#xa;&#xa;   for (int i = 1; i &lt;  numbers.length; i++)&#xa;      if (numbers[i] &gt;  result)&#xa;      result = numbers[i];&#xa;      System.out.println(&quot;The max value is &quot; + result);&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;The max value is 56.5&#xa;The max value is 3.0&#xa;The finalize( ) Method:&#xa;It is possible to define a method that will be called just before an object&apos;s final destruction by the garbage collector. This method is called finalize( ), and it can be used to ensure that an object terminates cleanly.&#xa;&#xa;For example, you might use finalize( ) to make sure that an open file owned by that object is closed.&#xa;&#xa;To add a finalizer to a class, you simply define the finalize( ) method. The Java runtime calls that method whenever it is about to recycle an object of that class.&#xa;&#xa;Inside the finalize( ) method, you will specify those actions that must be performed before an object is destroyed.&#xa;&#xa;The finalize( ) method has this general form:&#xa;&#xa;protected void finalize( )&#xa;{&#xa;   // finalization code here&#xa;}&#xa;Here, the keyword protected is a specifier that prevents access to finalize( ) by code defined outside its class.&#xa;&#xa;This means that you cannot know when or even if finalize( ) will be executed. For example, if your program ends before garbage collection occurs, finalize( ) will not execute." containsInvalidXMLChars="true"/>
                  </Properties>
                </Component>
              </SubComponents>
            </Container>
          </SubComponents>
        </Container>
        <Container class="javax.swing.JPanel" name="jPanel7">
          <Constraints>
            <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout" value="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout$JTabbedPaneConstraintsDescription">
              <JTabbedPaneConstraints tabName="Exceptions ">
                <Property name="tabTitle" type="java.lang.String" value="Exceptions "/>
              </JTabbedPaneConstraints>
            </Constraint>
          </Constraints>

          <Layout>
            <DimensionLayout dim="0">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane7" pref="1088" max="32767" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
            <DimensionLayout dim="1">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane7" pref="445" max="32767" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
          </Layout>
          <SubComponents>
            <Container class="javax.swing.JScrollPane" name="jScrollPane7">
              <AuxValues>
                <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
              </AuxValues>

              <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
              <SubComponents>
                <Component class="javax.swing.JTextArea" name="jTextArea7">
                  <Properties>
                    <Property name="columns" type="int" value="20"/>
                    <Property name="rows" type="int" value="5"/>
                    <Property name="text" type="java.lang.String" value="An exception (or exceptional event) is a problem that arises during the execution of a program. When an Exception occurs the normal flow of the program is disrupted and the program/Application terminates abnormally, which is not recommended, therefore these exceptions are to be handled.&#xa;&#xa;An exception can occur for many different reasons, below given are some scenarios where exception occurs.&#xa;&#xa;A user has entered invalid data.&#xa;&#xa;A file that needs to be opened cannot be found.&#xa;&#xa;A network connection has been lost in the middle of communications or the JVM has run out of memory.&#xa;&#xa;Some of these exceptions are caused by user error, others by programmer error, and others by physical resources that have failed in some manner.&#xa;&#xa;Based on these we have three categories of Exceptions you need to understand them to know how exception handling works in Java,&#xa;&#xa;Checked exceptions: A checked exception is an exception that occurs at the compile time, these are also called as compile time exceptions. These exceptions cannot simply be ignored at the time of compilation, the Programmer should take care of (handle) these exceptions.&#xa;&#xa;For example, if you use FileReader class in your program to read data from a file, if the file specified in its constructor doesn&apos;t exist, then an FileNotFoundException occurs, and compiler prompts the programmer to handle the exception.&#xa;import java.io.File;&#xa;import java.io.FileReader;&#xa;&#xa;public class FilenotFound_Demo {&#xa;&#xa;   public static void main(String args[]){&#x9;&#x9;&#xa;      File file=new File(&quot;E://file.txt&quot;);&#xa;      FileReader fr = new FileReader(file); &#xa;   }&#xa;   &#xa;} If you try to compile the above program you will get exceptions as shown below.&#xa; &#xa;&#xa;C:\u005c&gt;javac FilenotFound_Demo.java&#xa;FilenotFound_Demo.java:8: error: unreported exception FileNotFoundException; must be caught or declared to be thrown&#xa;      FileReader fr = new FileReader(file);&#xa;                      ^&#xa;1 error&#xa;Note: Since the methods read() and close() of FileReader class throws IOException, you can observe that compiler notifies to handle IOException, along with FileNotFoundException.&#xa;&#xa;Unchecked exceptions: An Unchecked exception is an exception that occurs at the time of execution, these are also called as Runtime Exceptions, these include programming bugs, such as logic errors or improper use of an API. runtime exceptions are ignored at the time of compilation.&#xa;&#xa;For example, if you have declared an array of size 5 in your program, and trying to call the 6th element of the array then an ArrayIndexOutOfBoundsExceptionexception occurs.&#xa;&#xa;public class Unchecked_Demo {&#xa;   &#xa;   public static void main(String args[]){&#xa;      int num[]={1,2,3,4};&#xa;      System.out.println(num[5]);&#xa;   }&#xa;&#xa;}&#xa;If you compile and execute the above program you will get exception as shown below.&#xa;&#xa;Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 5&#xa;&#x9;at Exceptions.Unchecked_Demo.main(Unchecked_Demo.java:8)&#xa;Errors: These are not exceptions at all, but problems that arise beyond the control of the user or the programmer. Errors are typically ignored in your code because you can rarely do anything about an error. For example, if a stack overflow occurs, an error will arise. They are also ignored at the time of compilation.&#xa;&#xa;Exception Hierarchy:&#xa;All exception classes are subtypes of the java.lang.Exception class. The exception class is a subclass of the Throwable class. Other than the exception class there is another subclass called Error which is derived from the Throwable class.&#xa;&#xa;Errors are not normally trapped form the Java programs. These conditions normally happen in case of severe failures, which are not handled by the java programs. Errors are generated to indicate errors generated by the runtime environment. Example : JVM is out of Memory. Normally programs cannot recover from errors.&#xa;&#xa;The Exception class has two main subclasses: IOException class and RuntimeException Class.&#xa;&#xa;Java Exceptions&#xa;Here is a list of most common checked and unchecked Java&apos;s Built-in Exceptions.&#xa;&#xa;Exceptions Methods:&#xa;Following is the list of important medthods available in the Throwable class.&#xa;&#xa;SN&#x9;Methods with Description&#xa;1&#x9;public String getMessage()&#xa;Returns a detailed message about the exception that has occurred. This message is initialized in the Throwable constructor.&#xa;&#xa;2&#x9;public Throwable getCause()&#xa;Returns the cause of the exception as represented by a Throwable object.&#xa;&#xa;3&#x9;public String toString()&#xa;Returns the name of the class concatenated with the result of getMessage()&#xa;&#xa;4&#x9;public void printStackTrace()&#xa;Prints the result of toString() along with the stack trace to System.err, the error output stream.&#xa;&#xa;5&#x9;public StackTraceElement [] getStackTrace()&#xa;Returns an array containing each element on the stack trace. The element at index 0 represents the top of the call stack, and the last element in the array represents the method at the bottom of the call stack.&#xa;&#xa;6&#x9;public Throwable fillInStackTrace()&#xa;Fills the stack trace of this Throwable object with the current stack trace, adding to any previous information in the stack trace.&#xa;&#xa;Catching Exceptions:&#xa;A method catches an exception using a combination of the try and catch keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following:&#xa;&#xa;try&#xa;{&#xa;   //Protected code&#xa;}catch(ExceptionName e1)&#xa;{&#xa;   //Catch block&#xa;}&#xa;The code which is prone to exceptions is placed in the try block, when an exception occurs, that exception occurred is handled by catch block associated with it. Every try block should be immediately followed either by a class block or finally block.&#xa;&#xa;A catch statement involves declaring the type of exception you are trying to catch. If an exception occurs in protected code, the catch block (or blocks) that follows the try is checked. If the type of exception that occurred is listed in a catch block, the exception is passed to the catch block much as an argument is passed into a method parameter.&#xa;&#xa;Example:&#xa;The following is an array is declared with 2 elements. Then the code tries to access the 3rd element of the array which throws an exception.&#xa;&#xa;// File Name : ExcepTest.java&#xa;import java.io.*;&#xa;public class ExcepTest{&#xa;&#xa;   public static void main(String args[]){&#xa;      try{&#xa;         int a[] = new int[2];&#xa;         System.out.println(&quot;Access element three :&quot; + a[3]);&#xa;      }catch(ArrayIndexOutOfBoundsException e){&#xa;         System.out.println(&quot;Exception thrown  :&quot; + e);&#xa;      }&#xa;      System.out.println(&quot;Out of the block&quot;);&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3&#xa;Out of the block&#xa;Multiple catch Blocks:&#xa;A try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following:&#xa;&#xa;try&#xa;{&#xa;   //Protected code&#xa;}catch(ExceptionType1 e1)&#xa;{&#xa;   //Catch block&#xa;}catch(ExceptionType2 e2)&#xa;{&#xa;   //Catch block&#xa;}catch(ExceptionType3 e3)&#xa;{&#xa;   //Catch block&#xa;}&#xa;The previous statements demonstrate three catch blocks, but you can have any number of them after a single try. If an exception occurs in the protected code, the exception is thrown to the first catch block in the list. If the data type of the exception thrown matches ExceptionType1, it gets caught there. If not, the exception passes down to the second catch statement. This continues until the exception either is caught or falls through all catches, in which case the current method stops execution and the exception is thrown down to the previous method on the call stack.&#xa;&#xa;Example:&#xa;Here is code segment showing how to use multiple try/catch statements.&#xa;&#xa;try&#xa;{&#xa;   file = new FileInputStream(fileName);&#xa;   x = (byte) file.read();&#xa;}catch(IOException i)&#xa;{&#xa;   i.printStackTrace();&#xa;   return -1;&#xa;}catch(FileNotFoundException f) //Not valid!&#xa;{&#xa;   f.printStackTrace();&#xa;   return -1;&#xa;}&#xa;Catching multiple type of exceptions&#xa;Since Java 7 you can handle more than one exceptions using a single catch block, this feature simplifies the code. Below given is the syntax of writing&#xa;&#xa;catch (IOException|FileNotFoundException ex) {&#xa;   logger.log(ex);&#xa;   throw ex;&#xa;The throws/throw Keywords:&#xa;If a method does not handle a checked exception, the method must declare it using the throws keyword. The throws keyword appears at the end of a method&apos;s signature.&#xa;&#xa;You can throw an exception, either a newly instantiated one or an exception that you just caught, by using the throw keyword.&#xa;&#xa;Try to understand the difference between throws and throw keywords, throws is used to postpone the handling of a checked exception and throw is used to invoke an exception explicitly.&#xa;The following method declares that it throws a RemoteException:&#xa;&#xa;import java.io.*;&#xa;public class className&#xa;{&#xa;   public void deposit(double amount) throws RemoteException&#xa;   {&#xa;      // Method implementation&#xa;      throw new RemoteException();&#xa;   }&#xa;   //Remainder of class definition&#xa;}&#xa;A method can declare that it throws more than one exception, in which case the exceptions are declared in a list separated by commas. For example, the following method declares that it throws a RemoteException and an InsufficientFundsException:&#xa;&#xa;import java.io.*;&#xa;public class className&#xa;{&#xa;   public void withdraw(double amount) throws RemoteException,&#xa;                              InsufficientFundsException&#xa;   {&#xa;       // Method implementation&#xa;   }&#xa;   //Remainder of class definition&#xa;}&#xa;The finally block&#xa;The finally block follows a try block or a catch block. A finally block of code always executes, irrespective of occurrence of an Exception.&#xa;&#xa;Using a finally block allows you to run any cleanup-type statements that you want to execute, no matter what happens in the protected code.&#xa;&#xa;A finally block appears at the end of the catch blocks and has the following syntax:&#xa;&#xa;try&#xa;{&#xa;   //Protected code&#xa;}catch(ExceptionType1 e1)&#xa;{&#xa;   //Catch block&#xa;}catch(ExceptionType2 e2)&#xa;{&#xa;   //Catch block&#xa;}catch(ExceptionType3 e3)&#xa;{&#xa;   //Catch block&#xa;}finally&#xa;{&#xa;   //The finally block always executes.&#xa;}&#xa;Example:&#xa;public class ExcepTest{&#xa;&#xa;   public static void main(String args[]){&#xa;      int a[] = new int[2];&#xa;      try{&#xa;         System.out.println(&quot;Access element three :&quot; + a[3]);&#xa;      }catch(ArrayIndexOutOfBoundsException e){&#xa;         System.out.println(&quot;Exception thrown  :&quot; + e);&#xa;      }&#xa;      finally{&#xa;         a[0] = 6;&#xa;         System.out.println(&quot;First element value: &quot; +a[0]);&#xa;         System.out.println(&quot;The finally statement is executed&quot;);&#xa;      }&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3&#xa;First element value: 6&#xa;The finally statement is executed&#xa;Note the following:&#xa;&#xa;A catch clause cannot exist without a try statement.&#xa;&#xa;It is not compulsory to have finally clauses when ever a try/catch block is present.&#xa;&#xa;The try block cannot be present without either catch clause or finally clause.&#xa;&#xa;Any code cannot be present in between the try, catch, finally blocks.&#xa;&#xa;The try-with-resources&#xa;Generally when we use any resources like streams, connections etc.. we have to close them explicitly using finally block. In the program given below we are reading data from a file using FileReader and we are closing it using finally block.&#xa;&#xa;import java.io.File;&#xa;import java.io.FileReader;&#xa;import java.io.IOException;&#xa;&#xa;public class ReadData_Demo {&#xa;&#xa;   public static void main(String args[]){&#xa;      FileReader fr=null;&#x9;&#x9;&#xa;      try{&#xa;         File file=new File(&quot;file.txt&quot;);&#xa;         fr = new FileReader(file);  char [] a = new char[50];&#xa;         fr.read(a); // reads the content to the array&#xa;         for(char c : a)&#xa;         System.out.print(c); //prints the characters one by one&#xa;      }catch(IOException e){&#xa;          e.printStackTrace();&#xa;       }&#xa;       finally{&#x9;&#xa;          try{&#xa;              fr.close();&#xa;          }catch(IOException ex){&#x9;&#x9;&#xa;               ex.printStackTrace();&#xa;           }&#xa;       }&#xa;    }&#xa;&#xa;}&#xa;try-with-resources, also referred as automatic resource management. is a new exception handling mechanism that was introduced in Java7, which automatically closes the resources used within the try catch block.&#xa;&#xa;To use this statement you simply need to declare the required resources within the parenthesis, the created resource will be closed automatically at the end of the block, below given is the syntax of try-with-resources statement.&#xa;&#xa;try(FileReader fr=new FileReader(&quot;file path&quot;))&#xa;   {&#xa;   //use the resource&#xa;   }catch(){&#xa;      //body of catch &#xa;    }&#xa;   }&#xa;Below given is the program that reads the data in a file using try-with-resources statement.&#xa;&#xa;import java.io.FileReader;&#xa;import java.io.IOException;&#xa;&#xa;public class Try_withDemo {&#xa;&#xa;   public static void main(String args[]){&#xa;      &#x9;&#x9;&#xa;      try(FileReader fr=new FileReader(&quot;E://file.txt&quot;)){&#xa;         char [] a = new char[50];&#xa;         fr.read(a); // reads the contentto the array&#xa;         for(char c : a)&#xa;         System.out.print(c); //prints the characters one by one&#xa;      }catch(IOException e){&#xa;          e.printStackTrace();&#xa;       }   &#xa;   }&#xa;}&#xa;Following points are to be kept in mind while working with try-with resources statement.&#xa;&#xa;To use a class with try-with-resources statement it should implement AutoCloseable interface and the close() method of it gets invoked automatically at runtime.&#xa;&#xa;You can declare more than one class in try-with-resources statement.&#xa;&#xa;while you declare multiple classes in the try block of try-with-resources statement these classes are closed in reverse order.&#xa;&#xa;Except the deceleration of resources within the parenthesis every thing is same as normal try/catch block of a try block.&#xa;&#xa;The resource declared in try gets instantiated just before the start of the try-block.&#xa;&#xa;The resource declared at the try block is implicitly declared as final.&#xa;&#xa;User-defined Exceptions:&#xa;You can create your own exceptions in Java. Keep the following points in mind when writing your own exception classes:&#xa;&#xa;All exceptions must be a child of Throwable.&#xa;&#xa;If you want to write a checked exception that is automatically enforced by the Handle or Declare Rule, you need to extend the Exception class.&#xa;&#xa;If you want to write a runtime exception, you need to extend the RuntimeException class.&#xa;&#xa;We can define our own Exception class as below:&#xa;&#xa;class MyException extends Exception{&#xa;}&#xa;You just need to extend the predefined Exception class to create your own Exception. These are considered to be checked exceptions. The following InsufficientFundsException class is a user-defined exception that extends the Exception class, making it a checked exception. An exception class is like any other class, containing useful fields and methods.&#xa;&#xa;Example:&#xa;// File Name InsufficientFundsException.java&#xa;import java.io.*;&#xa;&#xa;public class InsufficientFundsException extends Exception&#xa;{&#xa;   private double amount;&#xa;   public InsufficientFundsException(double amount)&#xa;   {&#xa;      this.amount = amount;&#xa;   } &#xa;   public double getAmount()&#xa;   {&#xa;      return amount;&#xa;   }&#xa;}&#xa;To demonstrate using our user-defined exception, the following CheckingAccount class contains a withdraw() method that throws an InsufficientFundsException.&#xa;&#xa;// File Name CheckingAccount.java&#xa;import java.io.*;&#xa;&#xa;public class CheckingAccount&#xa;{&#xa;   private double balance;&#xa;   private int number;&#xa;   &#xa;   public CheckingAccount(int number)&#xa;   {&#xa;      this.number = number;&#xa;   }&#xa;   &#xa;   public void deposit(double amount)&#xa;   {&#xa;      balance += amount;&#xa;   }&#xa;   &#xa;   public void withdraw(double amount) throws InsufficientFundsException&#xa;   {&#xa;      if(amount &lt;= balance)&#xa;      {&#xa;         balance -= amount;&#xa;      }&#xa;      else&#xa;      {&#xa;         double needs = amount - balance;&#xa;         throw new InsufficientFundsException(needs);&#xa;      }&#xa;   }&#xa;   &#xa;   public double getBalance()&#xa;   {&#xa;      return balance;&#xa;   }&#xa;   &#xa;   public int getNumber()&#xa;   {&#xa;      return number;&#xa;   }&#xa;}&#xa;The following BankDemo program demonstrates invoking the deposit() and withdraw() methods of CheckingAccount.&#xa;&#xa;// File Name BankDemo.java&#xa;public class BankDemo&#xa;{&#xa;   public static void main(String [] args)&#xa;   {&#xa;      CheckingAccount c = new CheckingAccount(101);&#xa;      System.out.println(&quot;Depositing $500...&quot;);&#xa;      c.deposit(500.00);&#xa;      &#xa;      try&#xa;      {&#xa;         System.out.println(&quot;\u005cnWithdrawing $100...&quot;);&#xa;         c.withdraw(100.00);&#xa;         System.out.println(&quot;\u005cnWithdrawing $600...&quot;);&#xa;         c.withdraw(600.00);&#xa;      }catch(InsufficientFundsException e)&#xa;      {&#xa;         System.out.println(&quot;Sorry, but you are short $&quot; + e.getAmount());&#xa;         e.printStackTrace();&#xa;      }&#xa;    }&#xa;}&#xa;Compile all the above three files and run BankDemo, this would produce the following result:&#xa;&#xa;Depositing $500...&#xa;&#xa;Withdrawing $100...&#xa;&#xa;Withdrawing $600...&#xa;Sorry, but you are short $200.0&#xa;InsufficientFundsException&#xa;        at CheckingAccount.withdraw(CheckingAccount.java:25)&#xa;        at BankDemo.main(BankDemo.java:13)&#xa;Common Exceptions:&#xa;In Java, it is possible to define two catergories of Exceptions and Errors.&#xa;&#xa;JVM Exceptions: - These are exceptions/errors that are exclusively or logically thrown by the JVM. Examples : NullPointerException, ArrayIndexOutOfBoundsException, ClassCastException,&#xa;&#xa;Programmatic exceptions: - These exceptions are thrown explicitly by the application or the API programmers Examples: IllegalArgumentException, IllegalStateException." containsInvalidXMLChars="true"/>
                  </Properties>
                </Component>
              </SubComponents>
            </Container>
          </SubComponents>
        </Container>
        <Container class="javax.swing.JPanel" name="jPanel9">
          <Constraints>
            <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout" value="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout$JTabbedPaneConstraintsDescription">
              <JTabbedPaneConstraints tabName="overriding">
                <Property name="tabTitle" type="java.lang.String" value="overriding"/>
              </JTabbedPaneConstraints>
            </Constraint>
          </Constraints>

          <Layout>
            <DimensionLayout dim="0">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane8" pref="1078" max="32767" attributes="0"/>
                      <EmptySpace max="-2" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
            <DimensionLayout dim="1">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane8" pref="445" max="32767" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
          </Layout>
          <SubComponents>
            <Container class="javax.swing.JScrollPane" name="jScrollPane8">
              <AuxValues>
                <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
              </AuxValues>

              <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
              <SubComponents>
                <Component class="javax.swing.JTextArea" name="jTextArea8">
                  <Properties>
                    <Property name="columns" type="int" value="20"/>
                    <Property name="rows" type="int" value="5"/>
                    <Property name="text" type="java.lang.String" value="In the previous chapter, we talked about super classes and sub classes. If a class inherits a method from its super class, then there is a chance to override the method provided that it is not marked final.&#xa;&#xa;The benefit of overriding is: ability to define a behaviour that&apos;s specific to the subclass type which means a subclass can implement a parent class method based on its requirement.&#xa;&#xa;In object-oriented terms, overriding means to override the functionality of an existing method.&#xa;&#xa;Example:&#xa;Let us look at an example.&#xa;&#xa;class Animal{&#xa;&#xa;   public void move(){&#xa;      System.out.println(&quot;Animals can move&quot;);&#xa;   }&#xa;}&#xa;&#xa;class Dog extends Animal{&#xa;&#xa;   public void move(){&#xa;      System.out.println(&quot;Dogs can walk and run&quot;);&#xa;   }&#xa;}&#xa;&#xa;public class TestDog{&#xa;&#xa;   public static void main(String args[]){&#xa;      Animal a = new Animal(); // Animal reference and object&#xa;      Animal b = new Dog(); // Animal reference but Dog object&#xa;&#xa;      a.move();// runs the method in Animal class&#xa;&#xa;      b.move();//Runs the method in Dog class&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;Animals can move&#xa;Dogs can walk and run&#xa;In the above example, you can see that the even though b is a type of Animal it runs the move method in the Dog class. The reason for this is: In compile time, the check is made on the reference type. However, in the runtime, JVM figures out the object type and would run the method that belongs to that particular object.&#xa;&#xa;Therefore, in the above example, the program will compile properly since Animal class has the method move. Then, at the runtime, it runs the method specific for that object.&#xa;&#xa;Consider the following example :&#xa;&#xa;class Animal{&#xa;&#xa;   public void move(){&#xa;      System.out.println(&quot;Animals can move&quot;);&#xa;   }&#xa;}&#xa;&#xa;class Dog extends Animal{&#xa;&#xa;   public void move(){&#xa;      System.out.println(&quot;Dogs can walk and run&quot;);&#xa;   }&#xa;   public void bark(){&#xa;      System.out.println(&quot;Dogs can bark&quot;);&#xa;   }&#xa;}&#xa;&#xa;public class TestDog{&#xa;&#xa;   public static void main(String args[]){&#xa;      Animal a = new Animal(); // Animal reference and object&#xa;      Animal b = new Dog(); // Animal reference but Dog object&#xa;&#xa;      a.move();// runs the method in Animal class&#xa;      b.move();//Runs the method in Dog class&#xa;      b.bark();&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;TestDog.java:30: cannot find symbol&#xa;symbol  : method bark()&#xa;location: class Animal&#xa;                b.bark();&#xa;                 ^&#xa;This program will throw a compile time error since b&apos;s reference type Animal doesn&apos;t have a method by the name of bark.&#xa;&#xa;Rules for method overriding:&#xa;The argument list should be exactly the same as that of the overridden method.&#xa;&#xa;The return type should be the same or a subtype of the return type declared in the original overridden method in the superclass.&#xa;&#xa;The access level cannot be more restrictive than the overridden method&apos;s access level. For example: if the superclass method is declared public then the overridding method in the sub class cannot be either private or protected.&#xa;&#xa;Instance methods can be overridden only if they are inherited by the subclass.&#xa;&#xa;A method declared final cannot be overridden.&#xa;&#xa;A method declared static cannot be overridden but can be re-declared.&#xa;&#xa;If a method cannot be inherited, then it cannot be overridden.&#xa;&#xa;A subclass within the same package as the instance&apos;s superclass can override any superclass method that is not declared private or final.&#xa;&#xa;A subclass in a different package can only override the non-final methods declared public or protected.&#xa;&#xa;An overriding method can throw any uncheck exceptions, regardless of whether the overridden method throws exceptions or not. However the overriding method should not throw checked exceptions that are new or broader than the ones declared by the overridden method. The overriding method can throw narrower or fewer exceptions than the overridden method.&#xa;&#xa;Constructors cannot be overridden.&#xa;&#xa;Using the super keyword:&#xa;When invoking a superclass version of an overridden method the super keyword is used.&#xa;&#xa;class Animal{&#xa;&#xa;   public void move(){&#xa;      System.out.println(&quot;Animals can move&quot;);&#xa;   }&#xa;}&#xa;&#xa;class Dog extends Animal{&#xa;&#xa;   public void move(){&#xa;      super.move(); // invokes the super class method&#xa;      System.out.println(&quot;Dogs can walk and run&quot;);&#xa;   }&#xa;}&#xa;&#xa;public class TestDog{&#xa;&#xa;   public static void main(String args[]){&#xa;&#xa;      Animal b = new Dog(); // Animal reference but Dog object&#xa;      b.move(); //Runs the method in Dog class&#xa;&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;Animals can move&#xa;Dogs can walk and run"/>
                  </Properties>
                </Component>
              </SubComponents>
            </Container>
          </SubComponents>
        </Container>
        <Container class="javax.swing.JPanel" name="jPanel10">
          <Constraints>
            <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout" value="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout$JTabbedPaneConstraintsDescription">
              <JTabbedPaneConstraints tabName="Polymorphism">
                <Property name="tabTitle" type="java.lang.String" value="Polymorphism"/>
              </JTabbedPaneConstraints>
            </Constraint>
          </Constraints>

          <Layout>
            <DimensionLayout dim="0">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane9" pref="1078" max="32767" attributes="0"/>
                      <EmptySpace max="-2" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
            <DimensionLayout dim="1">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane9" pref="434" max="32767" attributes="0"/>
                      <EmptySpace max="-2" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
          </Layout>
          <SubComponents>
            <Container class="javax.swing.JScrollPane" name="jScrollPane9">
              <AuxValues>
                <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
              </AuxValues>

              <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
              <SubComponents>
                <Component class="javax.swing.JTextArea" name="jTextArea9">
                  <Properties>
                    <Property name="columns" type="int" value="20"/>
                    <Property name="rows" type="int" value="5"/>
                    <Property name="text" type="java.lang.String" value="Polymorphism is the ability of an object to take on many forms. The most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class object.&#xa;&#xa;Any Java object that can pass more than one IS-A test is considered to be polymorphic. In Java, all Java objects are polymorphic since any object will pass the IS-A test for their own type and for the class Object.&#xa;&#xa;It is important to know that the only possible way to access an object is through a reference variable. A reference variable can be of only one type. Once declared, the type of a reference variable cannot be changed.&#xa;&#xa;The reference variable can be reassigned to other objects provided that it is not declared final. The type of the reference variable would determine the methods that it can invoke on the object.&#xa;&#xa;A reference variable can refer to any object of its declared type or any subtype of its declared type. A reference variable can be declared as a class or interface type.&#xa;&#xa;Example:&#xa;Let us look at an example.&#xa;&#xa;public interface Vegetarian{}&#xa;public class Animal{}&#xa;public class Deer extends Animal implements Vegetarian{}&#xa;Now, the Deer class is considered to be polymorphic since this has multiple inheritance. Following are true for the above example:&#xa;&#xa;A Deer IS-A Animal&#xa;&#xa;A Deer IS-A Vegetarian&#xa;&#xa;A Deer IS-A Deer&#xa;&#xa;A Deer IS-A Object&#xa;&#xa;When we apply the reference variable facts to a Deer object reference, the following declarations are legal:&#xa;&#xa;Deer d = new Deer();&#xa;Animal a = d;&#xa;Vegetarian v = d;&#xa;Object o = d;&#xa;All the reference variables d,a,v,o refer to the same Deer object in the heap.&#xa;&#xa;Virtual Methods:&#xa;In this section, I will show you how the behaviour of overridden methods in Java allows you to take advantage of polymorphism when designing your classes.&#xa;&#xa;We already have discussed method overriding, where a child class can override a method in its parent. An overridden method is essentially hidden in the parent class, and is not invoked unless the child class uses the super keyword within the overriding method.&#xa;&#xa;/* File name : Employee.java */&#xa;public class Employee&#xa;{&#xa;   private String name;&#xa;   private String address;&#xa;   private int number;&#xa;   public Employee(String name, String address, int number)&#xa;   {&#xa;      System.out.println(&quot;Constructing an Employee&quot;);&#xa;      this.name = name;&#xa;      this.address = address;&#xa;      this.number = number;&#xa;   }&#xa;   public void mailCheck()&#xa;   {&#xa;      System.out.println(&quot;Mailing a check to &quot; + this.name&#xa;       + &quot; &quot; + this.address);&#xa;   }&#xa;   public String toString()&#xa;   {&#xa;      return name + &quot; &quot; + address + &quot; &quot; + number;&#xa;   }&#xa;   public String getName()&#xa;   {&#xa;      return name;&#xa;   }&#xa;   public String getAddress()&#xa;   {&#xa;      return address;&#xa;   }&#xa;   public void setAddress(String newAddress)&#xa;   {&#xa;      address = newAddress;&#xa;   }&#xa;   public int getNumber()&#xa;   {&#xa;     return number;&#xa;   }&#xa;}&#xa;Now suppose we extend Employee class as follows:&#xa;&#xa;/* File name : Salary.java */&#xa;public class Salary extends Employee&#xa;{&#xa;   private double salary; //Annual salary&#xa;   public Salary(String name, String address, int number, double&#xa;      salary)&#xa;   {&#xa;       super(name, address, number);&#xa;       setSalary(salary);&#xa;   }&#xa;   public void mailCheck()&#xa;   {&#xa;       System.out.println(&quot;Within mailCheck of Salary class &quot;);&#xa;       System.out.println(&quot;Mailing check to &quot; + getName()&#xa;       + &quot; with salary &quot; + salary);&#xa;   }&#xa;   public double getSalary()&#xa;   {&#xa;       return salary;&#xa;   }&#xa;   public void setSalary(double newSalary)&#xa;   {&#xa;       if(newSalary &gt;= 0.0)&#xa;       {&#xa;          salary = newSalary;&#xa;       }&#xa;   }&#xa;   public double computePay()&#xa;   {&#xa;      System.out.println(&quot;Computing salary pay for &quot; + getName());&#xa;      return salary/52;&#xa;   }&#xa;}&#xa;Now, you study the following program carefully and try to determine its output:&#xa;&#xa;/* File name : VirtualDemo.java */&#xa;public class VirtualDemo&#xa;{&#xa;   public static void main(String [] args)&#xa;   {&#xa;      Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00);&#xa;      Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00);&#xa;      System.out.println(&quot;Call mailCheck using Salary reference --&quot;);&#xa;      s.mailCheck();&#xa;      System.out.println(&quot;\u005cn Call mailCheck using Employee reference--&quot;);&#xa;      e.mailCheck();&#xa;    }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;Constructing an Employee&#xa;Constructing an Employee&#xa;Call mailCheck using Salary reference --&#xa;Within mailCheck of Salary class&#xa;ailing check to Mohd Mohtashim with salary 3600.0&#xa;&#xa;Call mailCheck using Employee reference--&#xa;Within mailCheck of Salary class&#xa;ailing check to John Adams with salary 2400.0&#xa;Here, we instantiate two Salary objects . one using a Salary reference s, and the other using an Employee reference e.&#xa;&#xa;While invoking s.mailCheck() the compiler sees mailCheck() in the Salary class at compile time, and the JVM invokes mailCheck() in the Salary class at run time.&#xa;&#xa;Invoking mailCheck() on e is quite different because e is an Employee reference. When the compiler sees e.mailCheck(), the compiler sees the mailCheck() method in the Employee class.&#xa;&#xa;Here, at compile time, the compiler used mailCheck() in Employee to validate this statement. At run time, however, the JVM invokes mailCheck() in the Salary class.&#xa;&#xa;This behavior is referred to as virtual method invocation, and the methods are referred to as virtual methods. All methods in Java behave in this manner, whereby an overridden method is invoked at run time, no matter what data type the reference is that was used in the source code at compile time." containsInvalidXMLChars="true"/>
                  </Properties>
                </Component>
              </SubComponents>
            </Container>
          </SubComponents>
        </Container>
        <Container class="javax.swing.JPanel" name="jPanel11">
          <Constraints>
            <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout" value="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout$JTabbedPaneConstraintsDescription">
              <JTabbedPaneConstraints tabName="Abstraction &amp; Encapsulation">
                <Property name="tabTitle" type="java.lang.String" value="Abstraction &amp; Encapsulation"/>
              </JTabbedPaneConstraints>
            </Constraint>
          </Constraints>

          <Layout>
            <DimensionLayout dim="0">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane10" pref="1078" max="32767" attributes="0"/>
                      <EmptySpace max="-2" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
            <DimensionLayout dim="1">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane10" pref="445" max="32767" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
          </Layout>
          <SubComponents>
            <Container class="javax.swing.JScrollPane" name="jScrollPane10">
              <AuxValues>
                <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
              </AuxValues>

              <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
              <SubComponents>
                <Component class="javax.swing.JTextArea" name="jTextArea10">
                  <Properties>
                    <Property name="columns" type="int" value="20"/>
                    <Property name="rows" type="int" value="5"/>
                    <Property name="text" type="java.lang.String" value="Abstract Class&#xa;A class which contains the abstract keyword in its declaration is known as abstract class.&#xa;&#xa;Abstract classes may or may not contain abstract methods ie., methods with out body ( public void get(); )&#xa;&#xa;But, if a class have at least one abstract method, then the class must be declared abstract.&#xa;&#xa;If a class is declared abstract it cannot be instantiated.&#xa;&#xa;To use an abstract class you have to inherit it from another class, provide implementations to the abstract methods in it.&#xa;&#xa;If you inherit an abstract class you have to provide implementations to all the abstract methods in it.&#xa;&#xa;Example&#xa;This section provides you an example of the abstract class to create an abstract class just use the abstract keyword before the class keyword, in the class declaration .&#xa;/* File name : Employee.java */&#xa;public abstract class Employee&#xa;{&#xa;   private String name;&#xa;   private String address;&#xa;   private int number;&#xa;   public Employee(String name, String address, int number)&#xa;   {&#xa;      System.out.println(&quot;Constructing an Employee&quot;);&#xa;      this.name = name;&#xa;      this.address = address;&#xa;      this.number = number;&#xa;   }&#xa;   public double computePay()&#xa;   {&#xa;     System.out.println(&quot;Inside Employee computePay&quot;);&#xa;     return 0.0;&#xa;   }&#xa;   public void mailCheck()&#xa;   {&#xa;      System.out.println(&quot;Mailing a check to &quot; + this.name&#xa;       + &quot; &quot; + this.address);&#xa;   }&#xa;   public String toString()&#xa;   {&#xa;      return name + &quot; &quot; + address + &quot; &quot; + number;&#xa;   }&#xa;   public String getName()&#xa;   {&#xa;      return name;&#xa;   }&#xa;   public String getAddress()&#xa;   {&#xa;      return address;&#xa;   }&#xa;   public void setAddress(String newAddress)&#xa;   {&#xa;      address = newAddress;&#xa;   }&#xa;   public int getNumber()&#xa;   {&#xa;     return number;&#xa;   }&#xa;}&#xa;You can observe that except abstract methods the Employee class is same as normal class in Java. The class is now abstract, but it still has three fields, seven methods, and one constructor.&#xa;&#xa;Now you can try to instantiate the Employee class as shown below:&#xa;&#xa;/* File name : AbstractDemo.java */&#xa;public class AbstractDemo&#xa;{&#xa;   public static void main(String [] args)&#xa;   {&#xa;      /* Following is not allowed and would raise error */&#xa;      Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);&#xa;&#xa;      System.out.println(&quot;\u005cn Call mailCheck using Employee reference--&quot;);&#xa;      e.mailCheck();&#xa;    }&#xa;}&#xa;When you compile the above class, it gives you the following error:&#xa;&#xa;Employee.java:46: Employee is abstract; cannot be instantiated&#xa;      Employee e = new Employee(&quot;George W.&quot;, &quot;Houston, TX&quot;, 43);&#xa;                   ^&#xa;1 error&#xa;Inheriting the Abstract Class:&#xa;We can inherit the properties of Employee class just like concrete class as shown below:&#xa;&#xa;/* File name : Salary.java */&#xa;public class Salary extends Employee&#xa;{&#xa;   private double salary; //Annual salary&#xa;   public Salary(String name, String address, int number, double&#xa;      salary)&#xa;   {&#xa;       super(name, address, number);&#xa;       setSalary(salary);&#xa;   }&#xa;   public void mailCheck()&#xa;   {&#xa;       System.out.println(&quot;Within mailCheck of Salary class &quot;);&#xa;       System.out.println(&quot;Mailing check to &quot; + getName()&#xa;       + &quot; with salary &quot; + salary);&#xa;   }&#xa;   public double getSalary()&#xa;   {&#xa;       return salary;&#xa;   }&#xa;   public void setSalary(double newSalary)&#xa;   {&#xa;       if(newSalary &gt;= 0.0)&#xa;       {&#xa;          salary = newSalary;&#xa;       }&#xa;   }&#xa;   public double computePay()&#xa;   {&#xa;      System.out.println(&quot;Computing salary pay for &quot; + getName());&#xa;      return salary/52;&#xa;   }&#xa;}&#xa;Here, you cannot instantiate the Employee class, but you can instantiate the Salary Class, and using this instance you can access the all the three fields and seven methods of Employee class as shown below.&#xa;&#xa;/* File name : AbstractDemo.java */&#xa;public class AbstractDemo&#xa;{&#xa;   public static void main(String [] args)&#xa;   {&#xa;      Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00);&#xa;      Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00);&#xa;&#xa;      System.out.println(&quot;Call mailCheck using Salary reference --&quot;);&#xa;      s.mailCheck();&#xa;&#xa;      System.out.println(&quot;\u005cn Call mailCheck using Employee reference--&quot;);&#xa;      e.mailCheck();&#xa;    }&#xa;}&#xa;This produces the following result:&#xa;&#xa;Constructing an Employee&#xa;Constructing an Employee&#xa;Call mailCheck using  Salary reference --&#xa;Within mailCheck of Salary class&#xa;ailing check to Mohd Mohtashim with salary 3600.0&#xa;&#xa;Call mailCheck using Employee reference--&#xa;Within mailCheck of Salary class&#xa;ailing check to John Adams with salary 2400.&#xa;Abstract Methods:&#xa;If you want a class to contain a particular method but you want the actual implementation of that method to be determined by child classes, you can declare the method in the parent class as abstract.&#xa;&#xa;abstract keyword is used to declare the method as abstract.&#xa;&#xa;You have to place the abstract keyword before the method name in the method declaration.&#xa;&#xa;An abstract method contains a method signature, but no method body.&#xa;&#xa;Instead of curly braces an abstract method will have a semoi colon ( ; ) at the end.&#xa;&#xa;Below given is an example of the abstract method.&#xa;&#xa;public abstract class Employee&#xa;{&#xa;   private String name;&#xa;   private String address;&#xa;   private int number;&#xa;   &#xa;   public abstract double computePay();&#xa;   &#xa;   //Remainder of class definition&#xa;}&#xa;Declaring a method as abstract has two consequences:&#xa;&#xa;The class containing it must be declared as abstract.&#xa;&#xa;Any class inheriting the current class must either override the abstract method or declare itself as abstract.&#xa;&#xa;Note: Eventually, a descendant class has to implement the abstract method; otherwise, you would have a hierarchy of abstract classes that cannot be instantiated.&#xa;&#xa;Suppose Salary class is inherits the Employee class, then it should implement the computePay() method as shown below:&#xa;&#xa;/* File name : Salary.java */&#xa;public class Salary extends Employee&#xa;{&#xa;   private double salary; // Annual salary&#xa;  &#xa;   public double computePay()&#xa;   {&#xa;      System.out.println(&quot;Computing salary pay for &quot; + getName());&#xa;      return salary/52;&#xa;   }&#xa;&#xa;   //Remainder of class definition&#xa;}&#xa;&#xa;Encapsulation is one of the four fundamental OOP concepts. The other three are inheritance, polymorphism, and abstraction.&#xa;&#xa;Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as as single unit. In encapsulation the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class, therefore it is also known as data hiding.&#xa;&#xa;To achieve encapsulation in Java&#xa;&#xa;Declare the variables of a class as private.&#xa;&#xa;Provide public setter and getter methods to modify and view the variables values.&#xa;&#xa;Example:&#xa;Below given is an example that demonstrates how to achieve Encapsulation in Java:&#xa;&#xa;/* File name : EncapTest.java */&#xa;public class EncapTest{&#xa;&#xa;   private String name;&#xa;   private String idNum;&#xa;   private int age;&#xa;&#xa;   public int getAge(){&#xa;      return age;&#xa;   }&#xa;&#xa;   public String getName(){&#xa;      return name;&#xa;   }&#xa;&#xa;   public String getIdNum(){&#xa;      return idNum;&#xa;   }&#xa;&#xa;   public void setAge( int newAge){&#xa;      age = newAge;&#xa;   }&#xa;&#xa;   public void setName(String newName){&#xa;      name = newName;&#xa;   }&#xa;&#xa;   public void setIdNum( String newId){&#xa;      idNum = newId;&#xa;   }&#xa;}&#xa;The public setXXX() and getXXX() methods are the access points of the instance variables of the EncapTest class. Normally, these methods are referred as getters and setters. Therefore any class that wants to access the variables should access them through these getters and setters.&#xa;&#xa;The variables of the EncapTest class can be accessed as below::&#xa;&#xa;/* File name : RunEncap.java */&#xa;public class RunEncap{&#xa;&#xa;   public static void main(String args[]){&#xa;      EncapTest encap = new EncapTest();&#xa;      encap.setName(&quot;James&quot;);&#xa;      encap.setAge(20);&#xa;      encap.setIdNum(&quot;12343ms&quot;);&#xa;&#xa;      System.out.print(&quot;Name : &quot; + encap.getName() + &quot; Age : &quot; + encap.getAge());&#xa;    }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;Name : James Age : 20&#xa;Benefits of Encapsulation:&#xa;The fields of a class can be made read-only or write-only.&#xa;&#xa;A class can have total control over what is stored in its fields.&#xa;&#xa;The users of a class do not know how the class stores its data. A class can change the data type of a field and users of the class do not need to change any of their code." containsInvalidXMLChars="true"/>
                  </Properties>
                </Component>
              </SubComponents>
            </Container>
          </SubComponents>
        </Container>
        <Container class="javax.swing.JPanel" name="jPanel12">
          <Constraints>
            <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout" value="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout$JTabbedPaneConstraintsDescription">
              <JTabbedPaneConstraints tabName="interfaces And packges">
                <Property name="tabTitle" type="java.lang.String" value="interfaces And packges"/>
              </JTabbedPaneConstraints>
            </Constraint>
          </Constraints>

          <Layout>
            <DimensionLayout dim="0">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane11" pref="1078" max="32767" attributes="0"/>
                      <EmptySpace max="-2" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
            <DimensionLayout dim="1">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane11" pref="445" max="32767" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
          </Layout>
          <SubComponents>
            <Container class="javax.swing.JScrollPane" name="jScrollPane11">
              <AuxValues>
                <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
              </AuxValues>

              <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
              <SubComponents>
                <Component class="javax.swing.JTextArea" name="jTextArea11">
                  <Properties>
                    <Property name="columns" type="int" value="20"/>
                    <Property name="rows" type="int" value="5"/>
                    <Property name="text" type="java.lang.String" value="An interface is a reference type in Java, it is similar to class, it is a collection of abstract methods. A class implements an interface, thereby inheriting the abstract methods of the interface.&#xa;&#xa;Along with abstract methods an interface may also contain constants, default methods, static methods, and nested types. Method bodies exist only for default methods and static methods.&#xa;&#xa;Writing an interface is similar to writing a class. But a class describes the attributes and behaviours of an object. And an interface contains behaviours that a class implements.&#xa;&#xa;Unless the class that implements the interface is abstract, all the methods of the interface need to be defined in the class.&#xa;&#xa;An interface is similar to a class in the following ways:&#xa;&#xa;An interface can contain any number of methods.&#xa;&#xa;An interface is written in a file with a .java extension, with the name of the interface matching the name of the file.&#xa;&#xa;The byte code of an interface appears in a .class file.&#xa;&#xa;Interfaces appear in packages, and their corresponding bytecode file must be in a directory structure that matches the package name.&#xa;&#xa;However, an interface is different from a class in several ways, including:&#xa;&#xa;You cannot instantiate an interface.&#xa;&#xa;An interface does not contain any constructors.&#xa;&#xa;All of the methods in an interface are abstract.&#xa;&#xa;An interface cannot contain instance fields. The only fields that can appear in an interface must be declared both static and final.&#xa;&#xa;An interface is not extended by a class; it is implemented by a class.&#xa;&#xa;An interface can extend multiple interfaces.&#xa;&#xa;Declaring Interfaces:&#xa;The interface keyword is used to declare an interface. Here is a simple example to declare an interface:&#xa;&#xa;Example:&#xa;Below given is an example of an interface:&#xa;&#xa;/* File name : NameOfInterface.java */&#xa;import java.lang.*;&#xa;//Any number of import statements&#xa;&#xa;public interface NameOfInterface&#xa;{&#xa;   //Any number of final, static fields&#xa;   //Any number of abstract method declarations\u005c&#xa;}&#xa;Interfaces have the following properties:&#xa;&#xa;An interface is implicitly abstract. You do not need to use the abstract keyword while declaring an interface.&#xa;&#xa;Each method in an interface is also implicitly abstract, so the abstract keyword is not needed.&#xa;&#xa;Methods in an interface are implicitly public.&#xa;&#xa;Example:&#xa;/* File name : Animal.java */&#xa;interface Animal {&#xa;&#xa;   public void eat();&#xa;   public void travel();&#xa;}&#xa;Implementing Interfaces:&#xa;When a class implements an interface, you can think of the class as signing a contract, agreeing to perform the specific behaviors of the interface. If a class does not perform all the behaviors of the interface, the class must declare itself as abstract.&#xa;&#xa;A class uses the implements keyword to implement an interface. The implements keyword appears in the class declaration following the extends portion of the declaration.&#xa;&#xa;/* File name : MammalInt.java */&#xa;public class MammalInt implements Animal{&#xa;&#xa;   public void eat(){&#xa;      System.out.println(&quot;Mammal eats&quot;);&#xa;   }&#xa;&#xa;   public void travel(){&#xa;      System.out.println(&quot;Mammal travels&quot;);&#xa;   } &#xa;&#xa;   public int noOfLegs(){&#xa;      return 0;&#xa;   }&#xa;&#xa;   public static void main(String args[]){&#xa;      MammalInt m = new MammalInt();&#xa;      m.eat();&#xa;      m.travel();&#xa;   }&#xa;} &#xa;This would produce the following result:&#xa;&#xa;ammal eats&#xa;ammal travels&#xa;When overriding methods defined in interfaces there are several rules to be followed:&#xa;&#xa;Checked exceptions should not be declared on implementation methods other than the ones declared by the interface method or subclasses of those declared by the interface method.&#xa;&#xa;The signature of the interface method and the same return type or subtype should be maintained when overriding the methods.&#xa;&#xa;An implementation class itself can be abstract and if so interface methods need not be implemented.&#xa;&#xa;When implementation interfaces there are several rules:&#xa;&#xa;A class can implement more than one interface at a time.&#xa;&#xa;A class can extend only one class, but implement many interfaces.&#xa;&#xa;An interface can extend another interface, similarly to the way that a class can extend another class.&#xa;&#xa;Extending Interfaces:&#xa;An interface can extend another interface, similarly to the way that a class can extend another class. The extends keyword is used to extend an interface, and the child interface inherits the methods of the parent interface.&#xa;&#xa;The following Sports interface is extended by Hockey and Football interfaces.&#xa;&#xa;//Filename: Sports.java&#xa;public interface Sports&#xa;{&#xa;   public void setHomeTeam(String name);&#xa;   public void setVisitingTeam(String name);&#xa;}&#xa;&#xa;//Filename: Football.java&#xa;public interface Football extends Sports&#xa;{&#xa;   public void homeTeamScored(int points);&#xa;   public void visitingTeamScored(int points);&#xa;   public void endOfQuarter(int quarter);&#xa;}&#xa;&#xa;//Filename: Hockey.java&#xa;public interface Hockey extends Sports&#xa;{&#xa;   public void homeGoalScored();&#xa;   public void visitingGoalScored();&#xa;   public void endOfPeriod(int period);&#xa;   public void overtimePeriod(int ot);&#xa;}&#xa;The Hockey interface has four methods, but it inherits two from Sports; thus, a class that implements Hockey needs to implement all six methods. Similarly, a class that implements Football needs to define the three methods from Football and the two methods from Sports.&#xa;&#xa;Extending Multiple Interfaces:&#xa;A Java class can only extend one parent class. Multiple inheritance is not allowed. Interfaces are not classes, however, and an interface can extend more than one parent interface.&#xa;&#xa;The extends keyword is used once, and the parent interfaces are declared in a comma-separated list.&#xa;&#xa;For example, if the Hockey interface extended both Sports and Event, it would be declared as:&#xa;&#xa;public interface Hockey extends Sports, Event&#xa;Tagging Interfaces:&#xa;The most common use of extending interfaces occurs when the parent interface does not contain any methods. For example, the MouseListener interface in the java.awt.event package extended java.util.EventListener, which is defined as:&#xa;&#xa;package java.util;&#xa;public interface EventListener&#xa;{}&#xa;An interface with no methods in it is referred to as a tagging interface. There are two basic design purposes of tagging interfaces:&#xa;&#xa;Creates a common parent: As with the EventListener interface, which is extended by dozens of other interfaces in the Java API, you can use a tagging interface to create a common parent among a group of interfaces. For example, when an interface extends EventListener, the JVM knows that this particular interface is going to be used in an event delegation scenario.&#xa;&#xa;Adds a data type to a class: This situation is where the term tagging comes from. A class that implements a tagging interface does not need to define any methods (since the interface does not have any), but the class becomes an interface type through polymorphism.&#xa;&#xa;Packages are used in Java in order to prevent naming conflicts, to control access, to make searching/locating and usage of classes, interfaces, enumerations and annotations easier, etc.&#xa;&#xa;A Package can be defined as a grouping of related types (classes, interfaces, enumerations and annotations ) providing access protection and name space management.&#xa;&#xa;Some of the existing packages in Java are::&#xa;&#xa;java.lang - bundles the fundamental classes&#xa;&#xa;java.io - classes for input , output functions are bundled in this package&#xa;&#xa;Programmers can define their own packages to bundle group of classes/interfaces, etc. It is a good practice to group related classes implemented by you so that a programmer can easily determine that the classes, interfaces, enumerations, annotations are related.&#xa;&#xa;Since the package creates a new namespace there won&apos;t be any name conflicts with names in other packages. Using packages, it is easier to provide access control and it is also easier to locate the related classes.&#xa;&#xa;Creating a package:&#xa;While creating a package, you should choose a name for the package and include a package statement along with that name at the top of every source file that contains the classes, interfaces, enumerations, and annotation types that you want to include in the package.&#xa;&#xa;The package statement should be the first line in the source file. There can be only one package statement in each source file, and it applies to all types in the file.&#xa;&#xa;If a package statement is not used then the class, interfaces, enumerations, and annotation types will be placed in the current default package.&#xa;&#xa;To compile the Java programs with package statements you have to do use -d option as shown below.&#xa;&#xa;javac -d Destination_folder file_name.java&#xa;Then a folder with the given package name is created in the specified destination, and the compiled class files will be placed in that folder&#xa;&#xa;Example:&#xa;Let us look at an example that creates a package called animals. It is a good practice to use names of packages with lower case letters to avoid any conflicts with the names of classes, interfaces.&#xa;&#xa;Below given package example contains interface named animals:&#xa;&#xa;/* File name : Animal.java */&#xa;package animals;&#xa;interface Animal {&#xa;   public void eat();&#xa;   public void travel();&#xa;}&#xa;Now, let us implement the above interface in the same package animals:&#xa;&#xa;package animals;&#xa;&#xa;/* File name : MammalInt.java */&#xa;public class MammalInt implements Animal{&#xa;&#xa;   public void eat(){&#xa;      System.out.println(&quot;Mammal eats&quot;);&#xa;   }&#xa;&#xa;   public void travel(){&#xa;      System.out.println(&quot;Mammal travels&quot;);&#xa;   } &#xa;&#xa;   public int noOfLegs(){&#xa;      return 0;&#xa;   }&#xa;&#xa;   public static void main(String args[]){&#xa;      MammalInt m = new MammalInt();&#xa;      m.eat();&#xa;      m.travel();&#xa;   }&#xa;} &#xa;Now compile the java files as shown below:&#xa;&#xa;$ javac -d . Animal.java &#xa;$ javac -d . MammalInt.java&#xa;Now a package/folder with the name animals will be created in the current directory and these class files will be placed in it as shown below.&#xa;&#xa;tutorialspoint&#xa; &#xa;&#xa;You can execute the class file with in the package and get the result as shown below.&#xa;&#xa;$ java animals.MammalInt&#xa;ammal eats&#xa;ammal travels&#xa;The import Keyword:&#xa;If a class wants to use another class in the same package, the package name does not need to be used. Classes in the same package find each other without any special syntax.&#xa;&#xa;Example:&#xa;Here, a class named Boss is added to the payroll package that already contains Employee. The Boss can then refer to the Employee class without using the payroll prefix, as demonstrated by the following Boss class.&#xa;&#xa;package payroll;&#xa;&#xa;public class Boss&#xa;{&#xa;   public void payEmployee(Employee e)&#xa;   {&#xa;      e.mailCheck();&#xa;   }&#xa;}&#xa;What happens if the Employee class is not in the payroll package? The Boss class must then use one of the following techniques for referring to a class in a different package.&#xa;&#xa;The fully qualified name of the class can be used. For example:&#xa;&#xa;payroll.Employee&#xa;The package can be imported using the import keyword and the wild card (*). For example:&#xa;&#xa;import payroll.*;&#xa;The class itself can be imported using the import keyword. For example:&#xa;&#xa;import payroll.Employee;&#xa;Note: A class file can contain any number of import statements. The import statements must appear after the package statement and before the class declaration.&#xa;&#xa;The Directory Structure of Packages:&#xa;Two major results occur when a class is placed in a package:&#xa;&#xa;The name of the package becomes a part of the name of the class, as we just discussed in the previous section.&#xa;&#xa;The name of the package must match the directory structure where the corresponding bytecode resides.&#xa;&#xa;Here is simple way of managing your files in Java:&#xa;&#xa;Put the source code for a class, interface, enumeration, or annotation type in a text file whose name is the simple name of the type and whose extension is .java. For example:&#xa;&#xa;// File Name :  Car.java&#xa;&#xa;package vehicle;&#xa;&#xa;public class Car {&#xa;   // Class implementation.   &#xa;}&#xa;Now, put the source file in a directory whose name reflects the name of the package to which the class belongs:&#xa;&#xa;....\u005cvehicle\u005cCar.java&#xa;Now, the qualified class name and pathname would be as below:&#xa;&#xa;Class name -&gt; vehicle.Car&#xa;&#xa;Path name -&gt; vehicle\u005cCar.java (in windows)&#xa;&#xa;In general, a company uses its reversed Internet domain name for its package names. Example: A company&apos;s Internet domain name is apple.com, then all its package names would start with com.apple. Each component of the package name corresponds to a subdirectory.&#xa;&#xa;Example: The company had a com.apple.computers package that contained a Dell.java source file, it would be contained in a series of subdirectories like this:&#xa;&#xa;....\u005ccom\u005capple\u005ccomputers\u005cDell.java&#xa;At the time of compilation, the compiler creates a different output file for each class, interface and enumeration defined in it. The base name of the output file is the name of the type, and its extension is .class&#xa;&#xa;For example:&#xa;&#xa;// File Name: Dell.java&#xa;&#xa;package com.apple.computers;&#xa;public class Dell{&#xa;      &#xa;}&#xa;class Ups{&#xa;      &#xa;}&#xa;Now, compile this file as follows using -d option:&#xa;&#xa;$javac -d . Dell.java&#xa;This would put compiled files as follows:&#xa;&#xa;.\u005ccom\u005capple\u005ccomputers\u005cDell.class&#xa;.\u005ccom\u005capple\u005ccomputers\u005cUps.class&#xa;You can import all the classes or interfaces defined in \u005ccom\u005capple\u005ccomputers\u005c as follows:&#xa;&#xa;import com.apple.computers.*;&#xa;Like the .java source files, the compiled .class files should be in a series of directories that reflect the package name. However, the path to the .class files does not have to be the same as the path to the .java source files. You can arrange your source and class directories separately, as:&#xa;&#xa;&lt;path-one&gt;\u005csources\u005ccom\u005capple\u005ccomputers\u005cDell.java&#xa;&#xa;&lt;path-two&gt;\u005cclasses\u005ccom\u005capple\u005ccomputers\u005cDell.class&#xa;By doing this, it is possible to give the classes directory to other programmers without revealing your sources. You also need to manage source and class files in this manner so that the compiler and the Java Virtual Machine (JVM) can find all the types your program uses.&#xa;&#xa;The full path to the classes directory, &lt;path-two&gt;\u005cclasses, is called the class path, and is set with the CLASSPATH system variable. Both the compiler and the JVM construct the path to your .class files by adding the package name to the class path.&#xa;&#xa;Say &lt;path-two&gt;\u005cclasses is the class path, and the package name is com.apple.computers, then the compiler and JVM will look for .class files in &lt;path-two&gt;\u005cclasses\u005ccom\u005capple\u005ccompters.&#xa;&#xa;A class path may include several paths. Multiple paths should be separated by a semicolon (Windows) or colon (Unix). By default, the compiler and the JVM search the current directory and the JAR file containing the Java platform classes so that these directories are automatically in the class path.&#xa;&#xa;Set CLASSPATH System Variable:&#xa;To display the current CLASSPATH variable, use the following commands in Windows and UNIX (Bourne shell):&#xa;&#xa;In Windows -&gt; C:\u005c&gt; set CLASSPATH&#xa;&#xa;In UNIX -&gt; % echo $CLASSPATH&#xa;&#xa;To delete the current contents of the CLASSPATH variable, use :&#xa;&#xa;In Windows -&gt; C:\u005c&gt; set CLASSPATH=&#xa;&#xa;In UNIX -&gt; % unset CLASSPATH; export CLASSPATH&#xa;&#xa;To set the CLASSPATH variable:&#xa;&#xa;In Windows -&gt; set CLASSPATH=C:\u005cusers\u005cjack\u005cjava\u005cclasses&#xa;&#xa;In UNIX -&gt; % CLASSPATH=/home/jack/java/classes; export CLASSPATH" containsInvalidXMLChars="true"/>
                  </Properties>
                </Component>
              </SubComponents>
            </Container>
          </SubComponents>
        </Container>
        <Container class="javax.swing.JPanel" name="jPanel8">
          <Constraints>
            <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout" value="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout$JTabbedPaneConstraintsDescription">
              <JTabbedPaneConstraints tabName="inheritance">
                <Property name="tabTitle" type="java.lang.String" value="inheritance"/>
              </JTabbedPaneConstraints>
            </Constraint>
          </Constraints>

          <Layout>
            <DimensionLayout dim="0">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane12" pref="1078" max="32767" attributes="0"/>
                      <EmptySpace max="-2" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
            <DimensionLayout dim="1">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane12" pref="445" max="32767" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
          </Layout>
          <SubComponents>
            <Container class="javax.swing.JScrollPane" name="jScrollPane12">
              <AuxValues>
                <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
              </AuxValues>

              <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
              <SubComponents>
                <Component class="javax.swing.JTextArea" name="jTextArea12">
                  <Properties>
                    <Property name="columns" type="int" value="20"/>
                    <Property name="rows" type="int" value="5"/>
                    <Property name="text" type="java.lang.String" value="Inheritance can be defined as the process where one class acquires the properties (methods and fields) of another. With the use of inheritance the information is made manageable in a hierarchical order.&#xa;&#xa;The class which inherits the properties of other is known as subclass (derived class, child class) and the class whose properties are inherited is known as superclass (base class, parent class).&#xa;&#xa;extends Keyword&#xa;extends is the keyword used to inherit the properties of a class. Below given is the syntax of extends keyword.&#xa;&#xa;class Super{&#xa;.....&#xa;.....&#xa;}&#xa;&#xa;class Sub extends Super{&#xa;.....&#xa;.....&#xa;&#xa;}&#xa;Sample Code&#xa;Below given is an example demonstrating Java inheritance. In this example you can observe two classes namely Calculation and My_Calculation.&#xa;&#xa;Using extends keyword the My_Calculation inherits the methods addition() and Subtraction() of Calculation class.&#xa;&#xa;Copy and paste the program given below in a file with name My_Calculation.java&#xa;&#xa;class Calculation{ &#xa;   int z;&#xa;   public void addition(int x, int y){&#xa;      z=x+y;&#xa;      System.out.println(&quot;The sum of the given numbers:&quot;+z);&#xa;   }&#xa;   public void Substraction(int x,int y){&#xa;      z=x-y;&#xa;      System.out.println(&quot;The difference between the given numbers:&quot;+z);&#xa;   }&#xa;   &#xa;}&#xa;&#xa;public class My_Calculation extends Calculation{    &#xa;  &#xa;   public void multiplication(int x, int y){&#xa;      z=x*y;&#xa;      System.out.println(&quot;The product of the given numbers:&quot;+z);&#xa;   }&#xa;   public static void main(String args[]){&#xa;      int a=20, b=10;&#xa;      My_Calculation demo = new My_Calculation();&#xa;      demo.addition(a, b);&#xa;      demo.Substraction(a, b);&#xa;      demo.multiplication(a, b);      &#xa;      &#xa;   }&#xa;&#xa;}&#xa;Compile and execute the above code as shown below&#xa;&#xa;javac My_Calculation.java&#xa;java My_Calculation&#xa;After executing the program it will produce the following result.&#xa;&#xa;The sum of the given numbers:30&#xa;The difference between the given numbers:10&#xa;The product of the given numbers:200&#xa; &#xa;&#xa;In the given program when an object to My_Calculation class is created, a copy of the contents of the super class is made with in it. That is why, using the object of the subclass you can access the members of a super class.&#xa;&#xa;Inheritance&#xa;The Superclass reference variable can hold the subclass object, but using that variable you can access only the members of the superclass, so to access the members of both classes it is recommended to always create reference variable to the subclass.&#xa;&#xa;If you consider the above program you can instantiate the class as given below as well. But using the superclass reference variable ( cal in this case ) you cannot call the method multiplication(), which belongs to the subclass My_Calculation.&#xa;&#xa;Calculation cal=new My_Calculation();&#xa;demo.addition(a, b);&#xa;demo.Subtraction(a, b);&#xa;Note: A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.&#xa;&#xa;The super keyword&#xa;The super keyword is similar to this keyword following are the scenarios where the super keyword is used.&#xa;&#xa;It is used to differentiate the members of superclass from the members of subclass, if they have same names.&#xa;&#xa;It is used to invoke the superclass constructor from subclass.&#xa;&#xa;Differentiating the members&#xa;If a class is inheriting the properties of another class. And if the members of the superclass have the names same as the sub class, to differentiate these variables we use super keyword as shown below.&#xa;&#xa;super.variable&#xa;super.method();&#xa;Sample Code&#xa;This section provides you a program that demonstrates the usage of the super keyword.&#xa;&#xa;In the given program you have two classes namely Sub_class and Super_class, both have a method named display() with different implementations, and a variable named num with different values. We are invoking display() method of both classes and printing the value of the variable num of both classes, here you can observe that we have used super key word to differentiate the members of super class from sub class.&#xa;&#xa;Copy and paste the program in a file with name Sub_class.java.&#xa;&#xa;class Super_class{&#xa;&#xa;   int num=20;&#xa;   &#xa;   //display method of superclass&#xa;   public void display(){   &#xa;      System.out.println(&quot;This is the display method of superclass&quot;);&#xa;   }&#x9;&#xa;&#xa;}&#xa;&#xa;public class Sub_class extends Super_class {&#xa;&#xa;   int num=10;&#xa;   &#xa;   //display method of sub class&#xa;   public void display(){&#xa;      System.out.println(&quot;This is the display method of subclass&quot;);&#xa;   }&#xa;   &#xa;   public void my_method(){&#xa;&#x9;  &#xa;      //Instantiating subclass&#xa;      Sub_class sub=new Sub_class();&#xa;&#x9;  &#xa;      //Invoking the display() method of sub class&#xa;      sub.display();&#xa;&#x9;  &#xa;      //Invoking the display() method of superclass&#xa;      super.display();&#xa;&#x9;  &#xa;      //printing the value of variable num of subclass&#xa;      System.out.println(&quot;value of the variable named num in sub class:&quot;+ sub.num);&#xa;&#x9;&#x9;  &#xa;      //printing the value of variable num of superclass&#xa;      System.out.println(&quot;value of the variable named num in super class:&quot;+ super.num);     &#xa;   }&#xa;   &#xa;   public static void main(String args[]){&#xa;      Sub_class obj = new Sub_class();&#xa;      obj.my_method();&#xa;      &#xa;   }&#xa;}&#xa;Compile and execute the above code using the following syntax.&#xa;&#xa;javac Super_Demo&#xa;java Super&#xa;On executing the program you will get the following result:&#xa;&#xa;This is the display method of subclass&#xa;This is the display method of superclass&#xa;value of the variable named num in sub class:10&#xa;value of the variable named num in super class:20&#xa;Invoking Superclass constructor&#xa;If a class is inheriting the properties of another class, the subclass automatically acquires the default constructor of the super class. But if you want to call a parametrized constructor of the super class, you need to use the super keyword as shown below.&#xa;&#xa;super(values);&#xa;Sample Code&#xa;The program given in this section demonstrates how to use the super keyword to invoke the parametrized constructor of the superclass. This program contains a super class and a sub class, where the super class contains a parametrized constructor which accepts a string value, and we used the super keyword to invoke the parametrized constructor of the super class.&#xa;&#xa;Copy and paste the below given program in a file with name Subclass.java&#xa;&#xa;class Superclass{&#xa;   &#xa;   int age;&#xa;&#xa;   Superclass(int age){&#xa;      this.age=age; &#x9;&#x9; &#xa;   }&#xa;&#xa;   public void getAge(){&#xa;      System.out.println(&quot;The value of the variable named age in super class is: &quot; +age);&#xa;   }&#xa;&#xa;}&#xa;&#xa;public class Subclass extends Superclass {&#xa;   &#xa;   Subclass(int age){&#xa;      super(age);&#xa;   }&#xa;&#xa;   public static void main(String argd[]){&#xa;      Subclass s= new Subclass(24);&#xa;      s.getAge();&#xa;   }&#xa;&#xa;}&#xa;Compile and execute the above code using the following syntax.&#xa;&#xa;javac Subclass&#xa;java Subclass&#xa;On executing the program you will get the following result:&#xa;&#xa;The value of the variable named age in super class is: 24&#xa;IS-A Relationship:&#xa;IS-A is a way of saying : This object is a type of that object. Let us see how the extends keyword is used to achieve inheritance.&#xa;&#xa;public class Animal{&#xa;}&#xa;&#xa;public class Mammal extends Animal{&#xa;}&#xa;&#xa;public class Reptile extends Animal{&#xa;}&#xa;&#xa;public class Dog extends Mammal{&#xa;}&#xa;Now, based on the above example, In Object Oriented terms, the following are true:&#xa;&#xa;Animal is the superclass of Mammal class.&#xa;&#xa;Animal is the superclass of Reptile class.&#xa;&#xa;Mammal and Reptile are subclasses of Animal class.&#xa;&#xa;Dog is the subclass of both Mammal and Animal classes.&#xa;&#xa;Now, if we consider the IS-A relationship, we can say:&#xa;&#xa;Mammal IS-A Animal&#xa;&#xa;Reptile IS-A Animal&#xa;&#xa;Dog IS-A Mammal&#xa;&#xa;Hence : Dog IS-A Animal as well&#xa;&#xa;With use of the extends keyword the subclasses will be able to inherit all the properties of the superclass except for the private properties of the superclass.&#xa;&#xa;We can assure that Mammal is actually an Animal with the use of the instance operator.&#xa;&#xa;Example&#xa;class Animal{&#xa;}&#xa;&#xa;class Mammal extends Animal{&#xa;}&#xa;&#xa;class Reptile extends Animal{&#xa;}&#xa;&#xa;public class Dog extends Mammal{&#xa;&#xa;   public static void main(String args[]){&#xa;&#xa;      Animal a = new Animal();&#xa;      Mammal m = new Mammal();&#xa;      Dog d = new Dog();&#xa;&#xa;      System.out.println(m instanceof Animal);&#xa;      System.out.println(d instanceof Mammal);&#xa;      System.out.println(d instanceof Animal);&#xa;   }&#xa;}&#xa;This would produce the following result:&#xa;&#xa;true&#xa;true&#xa;true&#xa;Since we have a good understanding of the extends keyword let us look into how the implements keyword is used to get the IS-A relationship.&#xa;&#xa;The implements keyword is used by classes by inherit from interfaces. Interfaces can never be extended by the classes.&#xa;&#xa;Example&#xa;public interface Animal {&#xa;}&#xa;&#xa;public class Mammal implements Animal{&#xa;}&#xa;&#xa;public class Dog extends Mammal{&#xa;}&#xa;The instanceof Keyword&#xa;Let us use the instanceof operator to check determine whether Mammal is actually an Animal, and dog is actually an Animal&#xa;&#xa;interface Animal{}&#xa;&#xa;class Mammal implements Animal{}&#xa;&#xa;public class Dog extends Mammal{&#xa;   public static void main(String args[]){&#xa;&#xa;      Mammal m = new Mammal();&#xa;      Dog d = new Dog();&#xa;&#xa;      System.out.println(m instanceof Animal);&#xa;      System.out.println(d instanceof Mammal);&#xa;      System.out.println(d instanceof Animal);&#xa;   }&#xa;} &#xa;This would produce the following result:&#xa;&#xa;true&#xa;true&#xa;true&#xa;HAS-A relationship&#xa;These relationships are mainly based on the usage. This determines whether a certain class HAS-A certain thing. This relationship helps to reduce duplication of code as well as bugs.&#xa;&#xa;Lets us look into an example:&#xa;&#xa;public class Vehicle{}&#xa;public class Speed{}&#xa;public class Van extends Vehicle{&#xa;&#x9;private Speed sp;&#xa;} &#xa;This shows that class Van HAS-A Speed. By having a separate class for Speed, we do not have to put the entire code that belongs to speed inside the Van class., which makes it possible to reuse the Speed class in multiple applications.&#xa;&#xa;In Object-Oriented feature, the users do not need to bother about which object is doing the real work. To achieve this, the Van class hides the implementation details from the users of the Van class. So basically what happens is the users would ask the Van class to do a certain action and the Van class will either do the work by itself or ask another class to perform the action.&#xa;&#xa;Types of inheritance&#xa;There are various types of inheritance as demonstrated below.&#xa;&#xa;Java Tutorial&#xa;A very important fact to remember is that Java does not support multiple inheritance. This means that a class cannot extend more than one class. Therefore following is illegal:&#xa;&#xa;public class extends Animal, Mammal{} &#xa;However, a class can implement one or more interfaces. This has made Java get rid of the impossibility of multiple inheritance."/>
                  </Properties>
                </Component>
              </SubComponents>
            </Container>
          </SubComponents>
        </Container>
        <Container class="javax.swing.JPanel" name="jPanel1">
          <Constraints>
            <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout" value="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout$JTabbedPaneConstraintsDescription">
              <JTabbedPaneConstraints tabName="Introduction">
                <Property name="tabTitle" type="java.lang.String" value="Introduction"/>
              </JTabbedPaneConstraints>
            </Constraint>
          </Constraints>

          <Layout>
            <DimensionLayout dim="0">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane1" min="-2" pref="1078" max="-2" attributes="0"/>
                      <EmptySpace max="32767" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
            <DimensionLayout dim="1">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane1" min="-2" pref="588" max="-2" attributes="0"/>
                      <EmptySpace max="32767" attributes="0"/>
                  </Group>
              </Group>
            </DimensionLayout>
          </Layout>
          <SubComponents>
            <Container class="javax.swing.JScrollPane" name="jScrollPane1">
              <AuxValues>
                <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
              </AuxValues>

              <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
              <SubComponents>
                <Component class="javax.swing.JTextArea" name="jTextArea1">
                  <Properties>
                    <Property name="columns" type="int" value="20"/>
                    <Property name="rows" type="int" value="5"/>
                    <Property name="text" type="java.lang.String" value="Java programming language was originally developed by Sun Microsystems which was initiated by James Gosling and released in 1995 as core component of Sun Microsystems&apos; Java platform (Java 1.0 [J2SE]).&#xa;&#xa;The latest release of the Java Standard Edition is Java SE 8. With the advancement of Java and its widespread popularity, multiple configurations were built to suite various types of platforms. Ex: J2EE for Enterprise Applications, J2ME for Mobile Applications.&#xa;&#xa;The new J2 versions were renamed as Java SE, Java EE and Java ME respectively. Java is guaranteed to be Write Once, Run Anywhere.&#xa;&#xa;Java is:&#xa;&#xa;Object Oriented: In Java, everything is an Object. Java can be easily extended since it is based on the Object model.&#xa;&#xa;Platform independent: Unlike many other programming languages including C and C++, when Java is compiled, it is not compiled into platform specific machine, rather into platform independent byte code. This byte code is distributed over the web and interpreted by virtual Machine (JVM) on whichever platform it is being run.&#xa;&#xa;Simple: Java is designed to be easy to learn. If you understand the basic concept of OOP Java would be easy to master.&#xa;&#xa;Secure: With Java&apos;s secure feature it enables to develop virus-free, tamper-free systems. Authentication techniques are based on public-key encryption.&#xa;&#xa;Architectural-neutral: Java compiler generates an architecture-neutral object file format which makes the compiled code to be executable on many processors, with the presence of Java runtime system.&#xa;&#xa;Portable: Being architectural-neutral and having no implementation dependent aspects of the specification makes Java portable. Compiler in Java is written in ANSI C with a clean portability boundary which is a POSIX subset.&#xa;&#xa;Robust: Java makes an effort to eliminate error prone situations by emphasizing mainly on compile time error checking and runtime checking.&#xa;&#xa;Multithreaded: With Java&apos;s multithreaded feature it is possible to write programs that can do many tasks simultaneously. This design feature allows developers to construct smoothly running interactive applications.&#xa;&#xa;Interpreted: Java byte code is translated on the fly to native machine instructions and is not stored anywhere. The development process is more rapid and analytical since the linking is an incremental and light weight process.&#xa;&#xa;High Performance: With the use of Just-In-Time compilers, Java enables high performance.&#xa;&#xa;Distributed: Java is designed for the distributed environment of the internet.&#xa;&#xa;Dynamic: Java is considered to be more dynamic than C or C++ since it is designed to adapt to an evolving environment. Java programs can carry extensive amount of run-time information that can be used to verify and resolve accesses to objects on run-time.&#xa;&#xa;History of Java:&#xa;James Gosling initiated the Java language project in June 1991 for use in one of his many set-top box projects. The language, initially called Oak after an oak tree that stood outside Gosling&apos;s office, also went by the name Green and ended up later being renamed as Java, from a list of random words.&#xa;&#xa;Sun released the first public implementation as Java 1.0 in 1995. It promised Write Once, Run Anywhere(WORA), providing no-cost run-times on popular platforms.&#xa;&#xa;On 13 November 2006, Sun released much of Java as free and open source software under the terms of the GNU General Public License (GPL).&#xa;&#xa;On 8 May 2007, Sun finished the process, making all of Java&apos;s core code free and open-source, aside from a small portion of code to which Sun did not hold the copyright.&#xa;&#xa;Tools you will need:&#xa;For performing the examples discussed in this tutorial, you will need a Pentium 200-MHz computer with a minimum of 64 MB of RAM (128 MB of RAM recommended).&#xa;&#xa;You also will need the following softwares:&#xa;&#xa;Linux 7.1 or Windows xp/7/8 operating system.&#xa;&#xa;Java JDK 8&#xa;&#xa;Microsoft Notepad or any other text editor&#xa;&#xa;This tutorial will provide the necessary skills to create GUI, networking, and Web applications using Java.&#xa;&#xa;Try It Option:&#xa;We have provided you an option to compile and execute available code online. Just click on Try it button avaiable at top-right corner of the code window to compile and execute available code. There are certain examples which can not be executed online, so we have skipped those examples.&#xa;&#xa;public class MyFirstJavaProgram {&#xa;&#xa;    public static void main(String []args) {&#xa;       System.out.println(&quot;Hello World&quot;);&#xa;    }&#xa;} &#xa;There may be a case that you do not see the result of the compiled/executed code, in such case you can re-try to compile and execute the code using execute button available in compliation pop-up window."/>
                  </Properties>
                </Component>
              </SubComponents>
            </Container>
          </SubComponents>
        </Container>
      </SubComponents>
    </Container>
    <Component class="javax.swing.JButton" name="jButton1">
      <Properties>
        <Property name="text" type="java.lang.String" value="back"/>
      </Properties>
      <Events>
        <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="jButton1ActionPerformed"/>
      </Events>
    </Component>
    <Component class="javax.swing.JButton" name="jButton2">
      <Properties>
        <Property name="text" type="java.lang.String" value="exit"/>
      </Properties>
      <Events>
        <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="jButton2ActionPerformed"/>
      </Events>
    </Component>
    <Component class="javax.swing.JButton" name="jButton3">
      <Properties>
        <Property name="text" type="java.lang.String" value="Online Help"/>
      </Properties>
      <Events>
        <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="jButton3ActionPerformed"/>
      </Events>
    </Component>
  </SubComponents>
</Form>
